{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitmexClient = void 0;\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\nconst moment_1 = __importDefault(require(\"moment\"));\n\nconst BasicClient_1 = require(\"../BasicClient\");\n\nconst Candle_1 = require(\"../Candle\");\n\nconst CandlePeriod_1 = require(\"../CandlePeriod\");\n\nconst Level2Point_1 = require(\"../Level2Point\");\n\nconst Level2Snapshots_1 = require(\"../Level2Snapshots\");\n\nconst Level2Update_1 = require(\"../Level2Update\");\n\nconst NotImplementedFn_1 = require(\"../NotImplementedFn\");\n\nconst Ticker_1 = require(\"../Ticker\");\n\nconst Trade_1 = require(\"../Trade\");\n\nclass BitmexClient extends BasicClient_1.BasicClient {\n  /**\n  Documentation:\n  https://www.bitmex.com/app/wsAPI\n  */\n  constructor() {\n    let {\n      wssPath = \"wss://www.bitmex.com/realtime\",\n      watcherMs\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(wssPath, \"BitMEX\", undefined, watcherMs);\n    this._sendSubLevel2Snapshots = NotImplementedFn_1.NotImplementedFn;\n    this._sendUnsubLevel2Snapshots = NotImplementedFn_1.NotImplementedFn;\n    this._sendSubLevel3Snapshots = NotImplementedFn_1.NotImplementedFn;\n    this._sendUnsubLevel3Snapshots = NotImplementedFn_1.NotImplementedFn;\n    this._sendSubLevel3Updates = NotImplementedFn_1.NotImplementedFn;\n    this._sendUnsubLevel3Updates = NotImplementedFn_1.NotImplementedFn;\n    this.hasTickers = true;\n    this.hasTrades = true;\n    this.hasCandles = true;\n    this.hasLevel2Updates = true;\n    this.candlePeriod = CandlePeriod_1.CandlePeriod._1m;\n    this.constructL2Price = true;\n    this.l2PriceMap = new Map();\n    /**\n     * Keyed from remote_id, market.id\n     * */\n\n    this.tickerMap = new Map();\n  }\n\n  _sendSubTicker(remote_id) {\n    this._sendSubQuote(remote_id);\n\n    this._sendSubTrades(remote_id);\n  }\n\n  _sendUnsubTicker(remote_id) {\n    this._sendUnsubQuote(remote_id); // if we're still subscribed to trades for this symbol, don't unsub\n\n\n    if (!this._tradeSubs.has(remote_id)) {\n      this._sendUnsubTrades(remote_id);\n    }\n\n    this._deleteTicker(remote_id);\n  }\n\n  _sendSubQuote(remote_id) {\n    this._wss.send(JSON.stringify({\n      op: \"subscribe\",\n      args: [`quote:${remote_id}`]\n    }));\n  }\n\n  _sendUnsubQuote(remote_id) {\n    this._wss.send(JSON.stringify({\n      op: \"unsubscribe\",\n      args: [`quote:${remote_id}`]\n    }));\n  }\n\n  _sendSubTrades(remote_id) {\n    this._wss.send(JSON.stringify({\n      op: \"subscribe\",\n      args: [`trade:${remote_id}`]\n    }));\n  }\n\n  _sendUnsubTrades(remote_id) {\n    this._wss.send(JSON.stringify({\n      op: \"unsubscribe\",\n      args: [`trade:${remote_id}`]\n    }));\n  }\n\n  _sendSubCandles(remote_id) {\n    this._wss.send(JSON.stringify({\n      op: \"subscribe\",\n      args: [`tradeBin${candlePeriod(this.candlePeriod)}:${remote_id}`]\n    }));\n  }\n\n  _sendUnsubCandles(remote_id) {\n    this._wss.send(JSON.stringify({\n      op: \"unsubscribe\",\n      args: [`tradeBin${candlePeriod(this.candlePeriod)}:${remote_id}`]\n    }));\n  }\n\n  _sendSubLevel2Updates(remote_id) {\n    this._wss.send(JSON.stringify({\n      op: \"subscribe\",\n      args: [`orderBookL2:${remote_id}`]\n    }));\n  }\n\n  _sendUnsubLevel2Updates(remote_id) {\n    this._wss.send(JSON.stringify({\n      op: \"unsubscribe\",\n      args: [`orderBookL2:${remote_id}`]\n    }));\n  }\n\n  _onMessage(msgs) {\n    const message = JSON.parse(msgs);\n    const {\n      table,\n      action\n    } = message;\n\n    if (table === \"quote\") {\n      this._onQuoteMessage(message);\n\n      return;\n    }\n\n    if (table === \"trade\") {\n      if (action !== \"insert\") return;\n\n      for (const datum of message.data) {\n        const remote_id = datum.symbol; // trade\n\n        let market = this._tradeSubs.get(remote_id);\n\n        if (market) {\n          const trade = this._constructTrades(datum, market);\n\n          this.emit(\"trade\", trade, market);\n        } // ticker\n\n\n        market = this._tickerSubs.get(remote_id);\n\n        if (market) {\n          const ticker = this._constructTickerForTrade(datum, market);\n\n          if (this._isTickerReady(ticker)) {\n            this.emit(\"ticker\", ticker, market);\n          }\n        }\n      }\n\n      return;\n    } // candles\n\n\n    if (table && table.startsWith(\"tradeBin\")) {\n      for (const datum of message.data) {\n        const remote_id = datum.symbol;\n\n        const market = this._candleSubs.get(remote_id);\n\n        if (!market) continue;\n\n        const candle = this._constructCandle(datum);\n\n        this.emit(\"candle\", candle, market);\n      }\n\n      return;\n    }\n\n    if (table === \"orderBookL2\") {\n      /**\n      From testing, we've never encountered non-uniform markets in a single\n      message broadcast and will assume uniformity (though we will validate\n      in the construction methods).\n      */\n      const remote_id = message.data[0].symbol;\n\n      const market = this._level2UpdateSubs.get(remote_id);\n\n      if (!market) return;\n      /**\n      The partial action is sent when there is a new subscription. It contains\n      the snapshot of data. Updates may arrive prior to the snapshot but can\n      be discarded.\n      Otherwise it will be an insert, update, or delete action. All three of\n      those will be handles in l2update messages.\n      */\n\n      if (action === \"partial\") {\n        const snapshot = this._constructLevel2Snapshot(message.data, market);\n\n        this.emit(\"l2snapshot\", snapshot, market);\n      } else {\n        const update = this._constructLevel2Update(message, market);\n\n        this.emit(\"l2update\", update, market);\n      }\n\n      return;\n    }\n  }\n\n  _constructTrades(datum, market) {\n    const {\n      size,\n      side,\n      timestamp,\n      price,\n      trdMatchID\n    } = datum;\n    const unix = (0, moment_1.default)(timestamp).valueOf();\n    return new Trade_1.Trade({\n      exchange: \"BitMEX\",\n      base: market.base,\n      quote: market.quote,\n      id: market.id,\n      tradeId: trdMatchID.replace(/-/g, \"\"),\n      unix,\n      side: side.toLowerCase(),\n      price: price.toFixed(8),\n      amount: size.toFixed(8),\n      raw: datum // attach the raw data incase it is needed in raw format\n\n    });\n  }\n  /**\n  {\n    table: 'tradeBin1m',\n    action: 'insert',\n    data: [\n      {\n        timestamp: '2020-08-12T20:33:00.000Z',\n        symbol: 'XBTUSD',\n        open: 11563,\n        high: 11563,\n        low: 11560,\n        close: 11560.5,\n        trades: 158,\n        volume: 157334,\n        vwap: 11562.0303,\n        lastSize: 4000,\n        turnover: 1360824337,\n        homeNotional: 13.60824337,\n        foreignNotional: 157334\n      }\n    ]\n  }\n  */\n\n\n  _constructCandle(datum) {\n    const ts = (0, moment_1.default)(datum.timestamp).valueOf();\n    return new Candle_1.Candle(ts, datum.open.toFixed(8), datum.high.toFixed(8), datum.low.toFixed(8), datum.close.toFixed(8), datum.volume.toFixed(8));\n  }\n  /**\n  Snapshot message are sent when an l2orderbook is subscribed to.\n  This part is necessary to maintain a proper orderbook because\n  BitMEX sends updates with a unique price key and does not\n  include a price value. This code will maintain the price map\n  so that update messages can be constructed with a price.\n  */\n\n\n  _constructLevel2Snapshot(data, market) {\n    let asks = [];\n    const bids = [];\n\n    for (const datum of data) {\n      // Construct the price lookup map for all values supplied here.\n      // Per the documentation, the id is a unique value for the\n      // market and the price.\n      if (this.constructL2Price) {\n        this.l2PriceMap.set(datum.id, datum.price.toFixed(8));\n      } // build the data point\n\n\n      const point = new Level2Point_1.Level2Point(datum.price.toFixed(8), datum.size.toFixed(8), undefined, {\n        id: datum.id\n      }); // add the datapoint to the asks or bids depending if its sell or bid side\n\n      if (datum.side === \"Sell\") asks.push(point);else bids.push(point);\n    } // asks arrive in descending order (best ask last)\n    // ccxws standardizes so that best bid/ask are array index 0\n\n\n    asks = asks.reverse();\n    return new Level2Snapshots_1.Level2Snapshot({\n      exchange: \"BitMEX\",\n      base: market.base,\n      quote: market.quote,\n      id: market.id,\n      asks,\n      bids\n    });\n  }\n  /**\n  Update messages will arrive as either insert, update, or delete\n  messages. The data payload appears to be uniform for a market.\n  This code will do the heavy lifting on remapping the pricing\n  structure. BitMEX sends hte updates without a price and instead\n  include a unique identifer for the asset and the price.\n   Insert:\n    {\n      table: 'orderbookL2'\n      action: 'insert'\n      data: [{ symbol: 'XBTUSD', id: 8799198150, side: 'Sell', size: 1, price: 8018.5 }]\n    }\n   Update:\n    {\n      table: 'orderBookL2',\n      action: 'update',\n      data: [ { symbol: 'XBTUSD', id: 8799595600, side: 'Sell', size: 258136 } ]\n    }\n   Delete:\n    {\n      table: 'orderBookL2',\n      action: 'delete',\n      data: [ { symbol: 'XBTUSD', id: 8799198650, side: 'Sell' } ]\n    }\n   We will standardize these to the CCXWS format:\n    - Insert and update will have price and size\n    - Delete will have a size of 0.\n  */\n\n\n  _constructLevel2Update(msg, market) {\n    // get the data from the message\n    const data = msg.data;\n    const action = msg.action;\n    let asks = [];\n    const bids = [];\n\n    for (const datum of data) {\n      let price;\n      let size;\n      /**\n      In our testing, we've always seen message uniformity in the symbols.\n      For performance reasons we're going to batch these into a single\n      response. But if we have a piece of data that doesn't match the symbol\n      we want to throw an error instead of polluting the orderbook with\n      bad data.\n      */\n\n      if (datum.symbol !== market.id) {\n        throw new Error(`l2update symbol mismatch, expected ${market.id}, got ${datum.symbol}`);\n      } // Find the price based on the price identifier\n\n\n      if (this.constructL2Price) {\n        switch (action) {\n          // inserts will contain the price, we need to set these in the map\n          // we can also directly use the price value\n          case \"insert\":\n            price = datum.price.toFixed(8);\n            this.l2PriceMap.set(datum.id, price);\n            break;\n          // update will require us to look up the price from the map\n\n          case \"update\":\n            price = this.l2PriceMap.get(datum.id);\n            break;\n          // price will require us to look up the price from the map\n          // we also will want to delete the map value since it's\n          // no longer needed\n\n          case \"delete\":\n            price = this.l2PriceMap.get(datum.id);\n            this.l2PriceMap.delete(datum.id);\n            break;\n        }\n      } // Find the size\n\n\n      switch (action) {\n        case \"insert\":\n        case \"update\":\n          size = datum.size.toFixed(8);\n          break;\n\n        case \"delete\":\n          size = 0 .toFixed(8);\n          break;\n      }\n\n      if (!price) {\n        // eslint-disable-next-line no-console\n        console.warn(\"unknown price\", datum);\n      } // Construct the data point\n\n\n      const point = new Level2Point_1.Level2Point(price, size, undefined, {\n        type: action,\n        id: datum.id\n      }); // Insert into ask or bid\n\n      if (datum.side === \"Sell\") asks.push(point);else bids.push(point);\n    } // asks arrive in descending order (best ask last)\n    // ccxws standardizes so that best bid/ask are array index 0\n\n\n    asks = asks.reverse();\n    return new Level2Update_1.Level2Update({\n      exchange: \"BitMEX\",\n      base: market.base,\n      quote: market.quote,\n      id: market.id,\n      asks,\n      bids\n    });\n  }\n  /**\n  * Updates a ticker for a quote update. From\n  * testing, quote broadcasts are sorted from oldest to newest and are\n  * for a single market. The parent message looks like below and\n  * the last object in the array is provided to this method.\n  * {\n      table: 'quote',\n      action: 'insert',\n      data: [\n        {\n          timestamp: '2020-04-17T16:05:57.560Z',\n          symbol: 'XBTUSD',\n          bidSize: 689279,\n          bidPrice: 7055,\n          askPrice: 7055.5,\n          askSize: 927374\n        },\n        {\n          timestamp: '2020-04-17T16:05:58.016Z',\n          symbol: 'XBTUSD',\n          bidSize: 684279,\n          bidPrice: 7055,\n          askPrice: 7055.5,\n          askSize: 927374\n        }\n      ]\n    }\n  */\n\n\n  _onQuoteMessage(msg) {\n    const data = msg.data;\n    const lastQuote = data[data.length - 1];\n    const remote_id = lastQuote.symbol;\n\n    const market = this._tickerSubs.get(remote_id);\n\n    if (market) {\n      const ticker = this._constructTickerForQuote(lastQuote, market);\n\n      if (this._isTickerReady(ticker)) {\n        this.emit(\"ticker\", ticker, market);\n      }\n    }\n  }\n  /**\n  * Constructs a ticker from a single quote data\n  {\n    timestamp: '2020-04-17T16:05:58.016Z',\n    symbol: 'XBTUSD',\n    bidSize: 684279,\n    bidPrice: 7055,\n    askPrice: 7055.5,\n    askSize: 927374\n  }\n  */\n\n\n  _constructTickerForQuote(datum, market) {\n    const ticker = this._getTicker(market);\n\n    ticker.ask = datum.askPrice.toFixed();\n    ticker.askVolume = datum.askSize.toFixed();\n    ticker.bid = datum.bidPrice.toFixed();\n    ticker.bidVolume = datum.bidSize.toFixed();\n    ticker.timestamp = new Date(datum.timestamp).valueOf();\n    return ticker;\n  }\n  /**\n  * Updates a ticker for the market based on the trade informatio\n    {\n      timestamp: '2020-04-17T16:39:53.324Z',\n      symbol: 'XBTUSD',\n      side: 'Buy',\n      size: 20,\n      price: 7062,\n      tickDirection: 'ZeroPlusTick',\n      trdMatchID: 'e6101cc7-844e-25d2-e4a5-7e71d04439e3',\n      grossValue: 283200,\n      homeNotional: 0.002832,\n      foreignNotional: 20\n    }\n  */\n\n\n  _constructTickerForTrade(data, market) {\n    const ticker = this._getTicker(market);\n\n    ticker.last = data.price.toFixed();\n    ticker.timestamp = new Date(data.timestamp).valueOf();\n    return ticker;\n  }\n  /**\n   * Creates a blank ticker for the specified market. The Ticker class is optimized\n   * to maintain a consistent shape to prevent shape transitions and reduce garbage.\n   * @param {*} market\n   */\n\n\n  _createTicker(market) {\n    return new Ticker_1.Ticker({\n      exchange: \"BitMEX\",\n      base: market.base,\n      quote: market.quote\n    });\n  }\n  /**\n   * Retrieves a ticker for the market or constructs one if it doesn't exist\n   * @param {string} market\n   */\n\n\n  _getTicker(market) {\n    const remote_id = market.id;\n    let ticker = this.tickerMap.get(remote_id);\n\n    if (!ticker) {\n      ticker = this._createTicker(market);\n      this.tickerMap.set(remote_id, ticker);\n    }\n\n    return ticker;\n  }\n  /**\n   * Deletes cached ticker data after unsubbing from ticker.\n   */\n\n\n  _deleteTicker(remote_id) {\n    this.tickerMap.delete(remote_id);\n  }\n  /**\n   * Returns true when all required information is available\n   * in the ticker. Because the ticker is built from multiple stream\n   * testing will break if a ticker is prematurely emitted that does\n   * not contain all of the required data.\n   */\n\n\n  _isTickerReady(ticker) {\n    return !!(ticker.last && ticker.bid && ticker.ask);\n  }\n\n}\n\nexports.BitmexClient = BitmexClient;\n\nfunction candlePeriod(period) {\n  switch (period) {\n    case CandlePeriod_1.CandlePeriod._1m:\n      return \"1m\";\n\n    case CandlePeriod_1.CandlePeriod._5m:\n      return \"5m\";\n\n    case CandlePeriod_1.CandlePeriod._1h:\n      return \"1h\";\n\n    case CandlePeriod_1.CandlePeriod._1d:\n      return \"1d\";\n  }\n}","map":{"version":3,"sources":["/Users/Derek/workspace/crypto-visualizer/node_modules/ccxws/src/exchanges/BitmexClient.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\nimport moment from \"moment\";\nimport { BasicClient } from \"../BasicClient\";\nimport { Candle } from \"../Candle\";\nimport { CandlePeriod } from \"../CandlePeriod\";\nimport { ClientOptions } from \"../ClientOptions\";\nimport { Level2Point } from \"../Level2Point\";\nimport { Level2Snapshot } from \"../Level2Snapshots\";\nimport { Level2Update } from \"../Level2Update\";\nimport { Market } from \"../Market\";\nimport { NotImplementedFn } from \"../NotImplementedFn\";\nimport { Ticker } from \"../Ticker\";\nimport { Trade } from \"../Trade\";\n\nexport class BitmexClient extends BasicClient {\n    public candlePeriod: CandlePeriod;\n    public constructL2Price: boolean;\n\n    protected l2PriceMap: Map<string, string>;\n    protected tickerMap: Map<string, Ticker>;\n\n    protected _sendSubLevel2Snapshots = NotImplementedFn;\n    protected _sendUnsubLevel2Snapshots = NotImplementedFn;\n    protected _sendSubLevel3Snapshots = NotImplementedFn;\n    protected _sendUnsubLevel3Snapshots = NotImplementedFn;\n    protected _sendSubLevel3Updates = NotImplementedFn;\n    protected _sendUnsubLevel3Updates = NotImplementedFn;\n\n    /**\n    Documentation:\n    https://www.bitmex.com/app/wsAPI\n   */\n    constructor({ wssPath = \"wss://www.bitmex.com/realtime\", watcherMs }: ClientOptions = {}) {\n        super(wssPath, \"BitMEX\", undefined, watcherMs);\n        this.hasTickers = true;\n        this.hasTrades = true;\n        this.hasCandles = true;\n        this.hasLevel2Updates = true;\n        this.candlePeriod = CandlePeriod._1m;\n        this.constructL2Price = true;\n        this.l2PriceMap = new Map();\n\n        /**\n         * Keyed from remote_id, market.id\n         * */\n        this.tickerMap = new Map();\n    }\n\n    protected _sendSubTicker(remote_id) {\n        this._sendSubQuote(remote_id);\n        this._sendSubTrades(remote_id);\n    }\n\n    protected _sendUnsubTicker(remote_id) {\n        this._sendUnsubQuote(remote_id);\n        // if we're still subscribed to trades for this symbol, don't unsub\n        if (!this._tradeSubs.has(remote_id)) {\n            this._sendUnsubTrades(remote_id);\n        }\n        this._deleteTicker(remote_id);\n    }\n\n    protected _sendSubQuote(remote_id) {\n        this._wss.send(\n            JSON.stringify({\n                op: \"subscribe\",\n                args: [`quote:${remote_id}`],\n            }),\n        );\n    }\n\n    protected _sendUnsubQuote(remote_id) {\n        this._wss.send(\n            JSON.stringify({\n                op: \"unsubscribe\",\n                args: [`quote:${remote_id}`],\n            }),\n        );\n    }\n\n    protected _sendSubTrades(remote_id) {\n        this._wss.send(\n            JSON.stringify({\n                op: \"subscribe\",\n                args: [`trade:${remote_id}`],\n            }),\n        );\n    }\n\n    protected _sendUnsubTrades(remote_id) {\n        this._wss.send(\n            JSON.stringify({\n                op: \"unsubscribe\",\n                args: [`trade:${remote_id}`],\n            }),\n        );\n    }\n\n    protected _sendSubCandles(remote_id) {\n        this._wss.send(\n            JSON.stringify({\n                op: \"subscribe\",\n                args: [`tradeBin${candlePeriod(this.candlePeriod)}:${remote_id}`],\n            }),\n        );\n    }\n\n    protected _sendUnsubCandles(remote_id) {\n        this._wss.send(\n            JSON.stringify({\n                op: \"unsubscribe\",\n                args: [`tradeBin${candlePeriod(this.candlePeriod)}:${remote_id}`],\n            }),\n        );\n    }\n\n    protected _sendSubLevel2Updates(remote_id) {\n        this._wss.send(\n            JSON.stringify({\n                op: \"subscribe\",\n                args: [`orderBookL2:${remote_id}`],\n            }),\n        );\n    }\n\n    protected _sendUnsubLevel2Updates(remote_id) {\n        this._wss.send(\n            JSON.stringify({\n                op: \"unsubscribe\",\n                args: [`orderBookL2:${remote_id}`],\n            }),\n        );\n    }\n\n    protected _onMessage(msgs) {\n        const message = JSON.parse(msgs);\n        const { table, action } = message;\n\n        if (table === \"quote\") {\n            this._onQuoteMessage(message);\n            return;\n        }\n\n        if (table === \"trade\") {\n            if (action !== \"insert\") return;\n\n            for (const datum of message.data) {\n                const remote_id = datum.symbol;\n\n                // trade\n                let market = this._tradeSubs.get(remote_id);\n                if (market) {\n                    const trade = this._constructTrades(datum, market);\n                    this.emit(\"trade\", trade, market);\n                }\n\n                // ticker\n                market = this._tickerSubs.get(remote_id);\n                if (market) {\n                    const ticker = this._constructTickerForTrade(datum, market);\n                    if (this._isTickerReady(ticker)) {\n                        this.emit(\"ticker\", ticker, market);\n                    }\n                }\n            }\n            return;\n        }\n\n        // candles\n        if (table && table.startsWith(\"tradeBin\")) {\n            for (const datum of message.data) {\n                const remote_id = datum.symbol;\n                const market = this._candleSubs.get(remote_id);\n                if (!market) continue;\n\n                const candle = this._constructCandle(datum);\n                this.emit(\"candle\", candle, market);\n            }\n            return;\n        }\n\n        if (table === \"orderBookL2\") {\n            /**\n        From testing, we've never encountered non-uniform markets in a single\n        message broadcast and will assume uniformity (though we will validate\n        in the construction methods).\n       */\n            const remote_id = message.data[0].symbol;\n            const market = this._level2UpdateSubs.get(remote_id);\n\n            if (!market) return;\n\n            /**\n        The partial action is sent when there is a new subscription. It contains\n        the snapshot of data. Updates may arrive prior to the snapshot but can\n        be discarded.\n\n        Otherwise it will be an insert, update, or delete action. All three of\n        those will be handles in l2update messages.\n       */\n            if (action === \"partial\") {\n                const snapshot = this._constructLevel2Snapshot(message.data, market);\n                this.emit(\"l2snapshot\", snapshot, market);\n            } else {\n                const update = this._constructLevel2Update(message, market);\n                this.emit(\"l2update\", update, market);\n            }\n            return;\n        }\n    }\n\n    protected _constructTrades(datum, market: Market) {\n        const { size, side, timestamp, price, trdMatchID } = datum;\n        const unix = moment(timestamp).valueOf();\n        return new Trade({\n            exchange: \"BitMEX\",\n            base: market.base,\n            quote: market.quote,\n            id: market.id,\n            tradeId: trdMatchID.replace(/-/g, \"\"),\n            unix,\n            side: side.toLowerCase(),\n            price: price.toFixed(8),\n            amount: size.toFixed(8),\n            raw: datum, // attach the raw data incase it is needed in raw format\n        });\n    }\n\n    /**\n   {\n      table: 'tradeBin1m',\n      action: 'insert',\n      data: [\n        {\n          timestamp: '2020-08-12T20:33:00.000Z',\n          symbol: 'XBTUSD',\n          open: 11563,\n          high: 11563,\n          low: 11560,\n          close: 11560.5,\n          trades: 158,\n          volume: 157334,\n          vwap: 11562.0303,\n          lastSize: 4000,\n          turnover: 1360824337,\n          homeNotional: 13.60824337,\n          foreignNotional: 157334\n        }\n      ]\n    }\n   */\n    protected _constructCandle(datum) {\n        const ts = moment(datum.timestamp).valueOf();\n        return new Candle(\n            ts,\n            datum.open.toFixed(8),\n            datum.high.toFixed(8),\n            datum.low.toFixed(8),\n            datum.close.toFixed(8),\n            datum.volume.toFixed(8),\n        );\n    }\n\n    /**\n    Snapshot message are sent when an l2orderbook is subscribed to.\n    This part is necessary to maintain a proper orderbook because\n    BitMEX sends updates with a unique price key and does not\n    include a price value. This code will maintain the price map\n    so that update messages can be constructed with a price.\n   */\n    protected _constructLevel2Snapshot(data, market: Market) {\n        let asks = [];\n        const bids = [];\n        for (const datum of data) {\n            // Construct the price lookup map for all values supplied here.\n            // Per the documentation, the id is a unique value for the\n            // market and the price.\n            if (this.constructL2Price) {\n                this.l2PriceMap.set(datum.id, datum.price.toFixed(8));\n            }\n\n            // build the data point\n            const point = new Level2Point(\n                datum.price.toFixed(8),\n                datum.size.toFixed(8),\n                undefined,\n                {\n                    id: datum.id,\n                },\n            );\n\n            // add the datapoint to the asks or bids depending if its sell or bid side\n            if (datum.side === \"Sell\") asks.push(point);\n            else bids.push(point);\n        }\n\n        // asks arrive in descending order (best ask last)\n        // ccxws standardizes so that best bid/ask are array index 0\n        asks = asks.reverse();\n\n        return new Level2Snapshot({\n            exchange: \"BitMEX\",\n            base: market.base,\n            quote: market.quote,\n            id: market.id,\n            asks,\n            bids,\n        });\n    }\n\n    /**\n    Update messages will arrive as either insert, update, or delete\n    messages. The data payload appears to be uniform for a market.\n    This code will do the heavy lifting on remapping the pricing\n    structure. BitMEX sends hte updates without a price and instead\n    include a unique identifer for the asset and the price.\n\n    Insert:\n      {\n        table: 'orderbookL2'\n        action: 'insert'\n        data: [{ symbol: 'XBTUSD', id: 8799198150, side: 'Sell', size: 1, price: 8018.5 }]\n      }\n\n    Update:\n      {\n        table: 'orderBookL2',\n        action: 'update',\n        data: [ { symbol: 'XBTUSD', id: 8799595600, side: 'Sell', size: 258136 } ]\n      }\n\n    Delete:\n      {\n        table: 'orderBookL2',\n        action: 'delete',\n        data: [ { symbol: 'XBTUSD', id: 8799198650, side: 'Sell' } ]\n      }\n\n    We will standardize these to the CCXWS format:\n      - Insert and update will have price and size\n      - Delete will have a size of 0.\n   */\n    protected _constructLevel2Update(msg, market) {\n        // get the data from the message\n        const data = msg.data;\n        const action = msg.action;\n\n        let asks = [];\n        const bids = [];\n\n        for (const datum of data) {\n            let price;\n            let size;\n\n            /**\n        In our testing, we've always seen message uniformity in the symbols.\n        For performance reasons we're going to batch these into a single\n        response. But if we have a piece of data that doesn't match the symbol\n        we want to throw an error instead of polluting the orderbook with\n        bad data.\n      */\n            if (datum.symbol !== market.id) {\n                throw new Error(\n                    `l2update symbol mismatch, expected ${market.id}, got ${datum.symbol}`,\n                );\n            }\n\n            // Find the price based on the price identifier\n            if (this.constructL2Price) {\n                switch (action) {\n                    // inserts will contain the price, we need to set these in the map\n                    // we can also directly use the price value\n                    case \"insert\":\n                        price = datum.price.toFixed(8);\n                        this.l2PriceMap.set(datum.id, price);\n                        break;\n                    // update will require us to look up the price from the map\n                    case \"update\":\n                        price = this.l2PriceMap.get(datum.id);\n                        break;\n                    // price will require us to look up the price from the map\n                    // we also will want to delete the map value since it's\n                    // no longer needed\n                    case \"delete\":\n                        price = this.l2PriceMap.get(datum.id);\n                        this.l2PriceMap.delete(datum.id);\n                        break;\n                }\n            }\n\n            // Find the size\n            switch (action) {\n                case \"insert\":\n                case \"update\":\n                    size = datum.size.toFixed(8);\n                    break;\n                case \"delete\":\n                    size = (0).toFixed(8);\n                    break;\n            }\n\n            if (!price) {\n                // eslint-disable-next-line no-console\n                console.warn(\"unknown price\", datum);\n            }\n\n            // Construct the data point\n            const point = new Level2Point(price, size, undefined, { type: action, id: datum.id });\n\n            // Insert into ask or bid\n            if (datum.side === \"Sell\") asks.push(point);\n            else bids.push(point);\n        }\n\n        // asks arrive in descending order (best ask last)\n        // ccxws standardizes so that best bid/ask are array index 0\n        asks = asks.reverse();\n\n        return new Level2Update({\n            exchange: \"BitMEX\",\n            base: market.base,\n            quote: market.quote,\n            id: market.id,\n            asks,\n            bids,\n        });\n    }\n\n    /**\n   * Updates a ticker for a quote update. From\n   * testing, quote broadcasts are sorted from oldest to newest and are\n   * for a single market. The parent message looks like below and\n   * the last object in the array is provided to this method.\n   * {\n        table: 'quote',\n        action: 'insert',\n        data: [\n          {\n            timestamp: '2020-04-17T16:05:57.560Z',\n            symbol: 'XBTUSD',\n            bidSize: 689279,\n            bidPrice: 7055,\n            askPrice: 7055.5,\n            askSize: 927374\n          },\n          {\n            timestamp: '2020-04-17T16:05:58.016Z',\n            symbol: 'XBTUSD',\n            bidSize: 684279,\n            bidPrice: 7055,\n            askPrice: 7055.5,\n            askSize: 927374\n          }\n        ]\n      }\n   */\n    protected _onQuoteMessage(msg) {\n        const data = msg.data;\n        const lastQuote = data[data.length - 1];\n        const remote_id = lastQuote.symbol;\n        const market = this._tickerSubs.get(remote_id);\n        if (market) {\n            const ticker = this._constructTickerForQuote(lastQuote, market);\n            if (this._isTickerReady(ticker)) {\n                this.emit(\"ticker\", ticker, market);\n            }\n        }\n    }\n\n    /**\n   * Constructs a ticker from a single quote data\n    {\n      timestamp: '2020-04-17T16:05:58.016Z',\n      symbol: 'XBTUSD',\n      bidSize: 684279,\n      bidPrice: 7055,\n      askPrice: 7055.5,\n      askSize: 927374\n    }\n   */\n    protected _constructTickerForQuote(datum, market: Market) {\n        const ticker = this._getTicker(market);\n        ticker.ask = datum.askPrice.toFixed();\n        ticker.askVolume = datum.askSize.toFixed();\n        ticker.bid = datum.bidPrice.toFixed();\n        ticker.bidVolume = datum.bidSize.toFixed();\n        ticker.timestamp = new Date(datum.timestamp).valueOf();\n        return ticker;\n    }\n\n    /**\n   * Updates a ticker for the market based on the trade informatio\n      {\n        timestamp: '2020-04-17T16:39:53.324Z',\n        symbol: 'XBTUSD',\n        side: 'Buy',\n        size: 20,\n        price: 7062,\n        tickDirection: 'ZeroPlusTick',\n        trdMatchID: 'e6101cc7-844e-25d2-e4a5-7e71d04439e3',\n        grossValue: 283200,\n        homeNotional: 0.002832,\n        foreignNotional: 20\n      }\n   */\n    protected _constructTickerForTrade(data, market: Market) {\n        const ticker = this._getTicker(market);\n        ticker.last = data.price.toFixed();\n        ticker.timestamp = new Date(data.timestamp).valueOf();\n        return ticker;\n    }\n\n    /**\n     * Creates a blank ticker for the specified market. The Ticker class is optimized\n     * to maintain a consistent shape to prevent shape transitions and reduce garbage.\n     * @param {*} market\n     */\n    protected _createTicker(market: Market) {\n        return new Ticker({\n            exchange: \"BitMEX\",\n            base: market.base,\n            quote: market.quote,\n        });\n    }\n\n    /**\n     * Retrieves a ticker for the market or constructs one if it doesn't exist\n     * @param {string} market\n     */\n    protected _getTicker(market: Market): Ticker {\n        const remote_id = market.id;\n        let ticker = this.tickerMap.get(remote_id);\n        if (!ticker) {\n            ticker = this._createTicker(market);\n            this.tickerMap.set(remote_id, ticker);\n        }\n        return ticker;\n    }\n\n    /**\n     * Deletes cached ticker data after unsubbing from ticker.\n     */\n    protected _deleteTicker(remote_id: string) {\n        this.tickerMap.delete(remote_id);\n    }\n\n    /**\n     * Returns true when all required information is available\n     * in the ticker. Because the ticker is built from multiple stream\n     * testing will break if a ticker is prematurely emitted that does\n     * not contain all of the required data.\n     */\n    protected _isTickerReady(ticker: Ticker): boolean {\n        return !!(ticker.last && ticker.bid && ticker.ask);\n    }\n}\n\nfunction candlePeriod(period) {\n    switch (period) {\n        case CandlePeriod._1m:\n            return \"1m\";\n        case CandlePeriod._5m:\n            return \"5m\";\n        case CandlePeriod._1h:\n            return \"1h\";\n        case CandlePeriod._1d:\n            return \"1d\";\n    }\n}\n"]},"metadata":{},"sourceType":"script"}