{"ast":null,"code":"\"use strict\";\n/* eslint-disable prefer-const */\n\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n/* eslint-disable @typescript-eslint/no-floating-promises */\n\n/* eslint-disable @typescript-eslint/restrict-plus-operands */\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\n/* eslint-disable @typescript-eslint/require-await */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BiboxBasicClient = exports.BiboxClient = void 0;\n\nconst zlib_1 = __importDefault(require(\"zlib\"));\n\nconst events_1 = require(\"events\");\n\nconst Watcher_1 = require(\"../Watcher\");\n\nconst BasicClient_1 = require(\"../BasicClient\");\n\nconst Ticker_1 = require(\"../Ticker\");\n\nconst Trade_1 = require(\"../Trade\");\n\nconst Level2Point_1 = require(\"../Level2Point\");\n\nconst Level2Snapshots_1 = require(\"../Level2Snapshots\");\n\nconst Candle_1 = require(\"../Candle\");\n\nconst SubscriptionType_1 = require(\"../SubscriptionType\");\n\nconst CandlePeriod_1 = require(\"../CandlePeriod\");\n\nconst Throttle_1 = require(\"../flowcontrol/Throttle\");\n\nconst Util_1 = require(\"../Util\");\n\nconst NotImplementedFn_1 = require(\"../NotImplementedFn\");\n\nclass BiboxClient extends events_1.EventEmitter {\n  /**\n  Bibox allows listening to multiple markets on the same\n  socket. Unfortunately, they throw errors if you subscribe\n  to too more than 20 markets at a time re:\n  https://github.com/Biboxcom/API_Docs_en/wiki/WS_request#1-access-to-the-url\n  This makes like hard and we need to batch connections, which\n  is why we can't use the BasicMultiClient.\n  */\n  constructor(options) {\n    super();\n    this.subscribeLevel2Updates = NotImplementedFn_1.NotImplementedFn;\n    this.unsubscribeLevel2Updates = NotImplementedFn_1.NotImplementedAsyncFn;\n    this.subscribeLevel3Snapshots = NotImplementedFn_1.NotImplementedFn;\n    this.unsubscribeLevel3Snapshots = NotImplementedFn_1.NotImplementedAsyncFn;\n    this.subscribeLevel3Updates = NotImplementedFn_1.NotImplementedFn;\n    this.unsubscribeLevel3Updates = NotImplementedFn_1.NotImplementedFn;\n    /**\n    Stores the client used for each subscription request with teh\n    key: remoteId_subType\n    The value is the underlying client that is used.\n    */\n\n    this._subClients = new Map();\n    /**\n    List of all active clients. Clients will be removed when all\n    subscriptions have vanished.\n    */\n\n    this._clients = [];\n    this.options = options;\n    this.hasTickers = true;\n    this.hasTrades = true;\n    this.hasCandles = true;\n    this.hasLevel2Snapshots = true;\n    this.hasLevel2Updates = false;\n    this.hasLevel3Snapshots = false;\n    this.hasLevel3Updates = false;\n    this.subsPerClient = 20;\n    this.throttleMs = 200;\n    this._subscribe = (0, Throttle_1.throttle)(this.__subscribe.bind(this), this.throttleMs);\n    this.candlePeriod = CandlePeriod_1.CandlePeriod._1m;\n  }\n\n  subscribeTicker(market) {\n    this._subscribe(market, SubscriptionType_1.SubscriptionType.ticker);\n  }\n\n  async unsubscribeTicker(market) {\n    this._unsubscribe(market, SubscriptionType_1.SubscriptionType.ticker);\n  }\n\n  subscribeTrades(market) {\n    this._subscribe(market, SubscriptionType_1.SubscriptionType.trade);\n  }\n\n  unsubscribeTrades(market) {\n    this._unsubscribe(market, SubscriptionType_1.SubscriptionType.trade);\n  }\n\n  subscribeCandles(market) {\n    this._subscribe(market, SubscriptionType_1.SubscriptionType.candle);\n  }\n\n  async unsubscribeCandles(market) {\n    this._unsubscribe(market, SubscriptionType_1.SubscriptionType.candle);\n  }\n\n  async subscribeLevel2Snapshots(market) {\n    this._subscribe(market, SubscriptionType_1.SubscriptionType.level2snapshot);\n  }\n\n  async unsubscribeLevel2Snapshots(market) {\n    this._unsubscribe(market, SubscriptionType_1.SubscriptionType.level2snapshot);\n  }\n\n  close() {\n    this._subscribe.cancel();\n\n    for (const client of this._clients) {\n      client.close();\n    }\n  }\n\n  async reconnect() {\n    for (const client of this._clients) {\n      client.reconnect();\n      await (0, Util_1.wait)(this.timeoutMs);\n    }\n  }\n\n  __subscribe(market, subscriptionType) {\n    // construct the subscription key from the remote_id and the type\n    // of subscription being performed\n    const subKey = market.id + \"_\" + subscriptionType; // try to find the subscription client from the existing lookup\n\n    let client = this._subClients.get(subKey); // if we haven't seen this market sub before first try\n    // to find an available existing client\n\n\n    if (!client) {\n      // first try to find a client that has less than 20 subscriptions...\n      client = this._clients.find(p => p.subCount < this.subsPerClient); // make sure we set the value\n\n      this._subClients.set(subKey, client);\n    } // if we were unable to find any avaialble clients, we will need\n    // to create a new client.\n\n\n    if (!client) {\n      // construct a new client\n      client = new BiboxBasicClient(this.options); // set properties\n\n      client.parent = this; // wire up the events to pass through\n\n      client.on(\"connecting\", () => this.emit(\"connecting\", market, subscriptionType));\n      client.on(\"connected\", () => this.emit(\"connected\", market, subscriptionType));\n      client.on(\"disconnected\", () => this.emit(\"disconnected\", market, subscriptionType));\n      client.on(\"reconnecting\", () => this.emit(\"reconnecting\", market, subscriptionType));\n      client.on(\"closing\", () => this.emit(\"closing\", market, subscriptionType));\n      client.on(\"closed\", () => this.emit(\"closed\", market, subscriptionType));\n      client.on(\"ticker\", (ticker, market) => this.emit(\"ticker\", ticker, market));\n      client.on(\"trade\", (trade, market) => this.emit(\"trade\", trade, market));\n      client.on(\"candle\", (candle, market) => this.emit(\"candle\", candle, market));\n      client.on(\"l2snapshot\", (l2snapshot, market) => this.emit(\"l2snapshot\", l2snapshot, market));\n      client.on(\"error\", err => this.emit(\"error\", err)); // push it into the list of clients\n\n      this._clients.push(client); // make sure we set the value\n\n\n      this._subClients.set(subKey, client);\n    } // now that we have a client, call the sub method, which\n    // should be an idempotent method, so no harm in calling it again\n\n\n    switch (subscriptionType) {\n      case SubscriptionType_1.SubscriptionType.ticker:\n        client.subscribeTicker(market);\n        break;\n\n      case SubscriptionType_1.SubscriptionType.trade:\n        client.subscribeTrades(market);\n        break;\n\n      case SubscriptionType_1.SubscriptionType.candle:\n        client.subscribeCandles(market);\n        break;\n\n      case SubscriptionType_1.SubscriptionType.level2snapshot:\n        client.subscribeLevel2Snapshots(market);\n        break;\n    }\n  }\n\n  _unsubscribe(market, subscriptionType) {\n    // construct the subscription key from the remote_id and the type\n    // of subscription being performed\n    const subKey = market.id + \"_\" + subscriptionType; // find the client\n\n    const client = this._subClients.get(subKey); // abort if nothign to do\n\n\n    if (!client) return; // perform the unsubscribe operation\n\n    switch (subscriptionType) {\n      case SubscriptionType_1.SubscriptionType.ticker:\n        client.unsubscribeTicker(market);\n        break;\n\n      case SubscriptionType_1.SubscriptionType.trade:\n        client.unsubscribeTrades(market);\n        break;\n\n      case SubscriptionType_1.SubscriptionType.candle:\n        client.unsubscribeCandles(market);\n        break;\n\n      case SubscriptionType_1.SubscriptionType.level2snapshot:\n        client.unsubscribeLevel2Snapshots(market);\n        break;\n    } // remove the client if nothing left to do\n\n\n    if (client.subCount === 0) {\n      client.close();\n\n      const idx = this._clients.indexOf(client);\n\n      this._clients.splice(idx, 1);\n    }\n  }\n\n}\n\nexports.BiboxClient = BiboxClient;\n\nclass BiboxBasicClient extends BasicClient_1.BasicClient {\n  /**\n  Manages connections for a single market. A single\n  socket is only allowed to work for 20 markets.\n  */\n  constructor() {\n    let {\n      wssPath = \"wss://push.bibox.com\",\n      watcherMs = 600 * 1000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(wssPath, \"Bibox\");\n    this._sendSubLevel2Updates = NotImplementedFn_1.NotImplementedFn;\n    this._sendUnsubLevel2Updates = NotImplementedFn_1.NotImplementedAsyncFn;\n    this._sendSubLevel3Snapshots = NotImplementedFn_1.NotImplementedFn;\n    this._sendUnsubLevel3Snapshots = NotImplementedFn_1.NotImplementedAsyncFn;\n    this._sendSubLevel3Updates = NotImplementedFn_1.NotImplementedFn;\n    this._sendUnsubLevel3Updates = NotImplementedFn_1.NotImplementedAsyncFn;\n    this._watcher = new Watcher_1.Watcher(this, watcherMs);\n    this.hasTickers = true;\n    this.hasTrades = true;\n    this.hasCandles = true;\n    this.hasLevel2Snapshots = true;\n    this.subCount = 0;\n  }\n\n  get candlePeriod() {\n    return this.parent.candlePeriod;\n  }\n  /**\n  Server will occassionally send ping messages. Client is expected\n  to respond with a pong message that matches the identifier.\n  If client fails to do this, server will abort connection after\n  second attempt.\n  */\n\n\n  _sendPong(id) {\n    this._wss.send(JSON.stringify({\n      pong: id\n    }));\n  }\n\n  _sendSubTicker(remote_id) {\n    this.subCount++;\n\n    this._wss.send(JSON.stringify({\n      event: \"addChannel\",\n      channel: `bibox_sub_spot_${remote_id}_ticker`\n    }));\n  }\n\n  async _sendUnsubTicker(remote_id) {\n    this.subCount--;\n\n    this._wss.send(JSON.stringify({\n      event: \"removeChannel\",\n      channel: `bibox_sub_spot_${remote_id}_ticker`\n    }));\n  }\n\n  async _sendSubTrades(remote_id) {\n    this.subCount++;\n\n    this._wss.send(JSON.stringify({\n      event: \"addChannel\",\n      channel: `bibox_sub_spot_${remote_id}_deals`\n    }));\n  }\n\n  _sendUnsubTrades(remote_id) {\n    this.subCount--;\n\n    this._wss.send(JSON.stringify({\n      event: \"removeChannel\",\n      channel: `bibox_sub_spot_${remote_id}_deals`\n    }));\n  }\n\n  _sendSubCandles(remote_id) {\n    this.subCount++;\n\n    this._wss.send(JSON.stringify({\n      event: \"addChannel\",\n      channel: `bibox_sub_spot_${remote_id}_kline_${candlePeriod(this.candlePeriod)}`\n    }));\n  }\n\n  async _sendUnsubCandles(remote_id) {\n    this.subCount--;\n\n    this._wss.send(JSON.stringify({\n      event: \"removeChannel\",\n      channel: `bibox_sub_spot_${remote_id}_kline_${candlePeriod(this.candlePeriod)}`\n    }));\n  }\n\n  async _sendSubLevel2Snapshots(remote_id) {\n    this.subCount++;\n\n    this._wss.send(JSON.stringify({\n      event: \"addChannel\",\n      channel: `bibox_sub_spot_${remote_id}_depth`\n    }));\n  }\n\n  async _sendUnsubLevel2Snapshots(remote_id) {\n    this.subCount--;\n\n    this._wss.send(JSON.stringify({\n      event: \"removeChannel\",\n      channel: `bibox_sub_spot_${remote_id}_depth`\n    }));\n  }\n  /**\n  Message usually arives as a string, that must first be converted\n  to JSON. Then we can process each message in the payload and\n  perform gunzip on the data.\n  */\n\n\n  _onMessage(raw) {\n    const msgs = typeof raw == \"string\" ? JSON.parse(raw) : raw;\n\n    if (Array.isArray(msgs)) {\n      for (const msg of msgs) {\n        this._processsMessage(msg);\n      }\n    } else {\n      this._processsMessage(msgs);\n    }\n  }\n  /**\n  Process the individaul message that was sent from the server.\n  Message will be informat:\n   {\n    channel: 'bibox_sub_spot_BTC_USDT_deals',\n    binary: '1',\n    data_type: 1,\n    data:\n      'H4sIAAAAAAAA/xTLMQ6CUAyA4bv8c0Ne4RWeHdUbiJMxhghDB5QgTsa7Gw/wXT4sQ6w4+/5wO5+OPcIW84SrWdPtsllbrAjLGvcJJ6cmVZoNYZif78eGo1UqjSK8YvxLIUa8bjWnrtbyvf4CAAD//1PFt6BnAAAA'\n  }\n  */\n\n\n  _processsMessage(msg) {\n    // if we detect gzip data, we need to process it\n    if (msg.binary == 1) {\n      const buffer = zlib_1.default.gunzipSync(Buffer.from(msg.data, \"base64\"));\n      msg.data = JSON.parse(buffer.toString());\n    } // server will occassionally send a ping message and client\n    // must respon with appropriate identifier\n\n\n    if (msg.ping) {\n      this._sendPong(msg.ping);\n\n      return;\n    } // watch for error messages\n\n\n    if (msg.error) {\n      const err = new Error(msg.error);\n      err.message = msg;\n      this.emit(\"error\", err);\n      return;\n    }\n\n    if (!msg.channel) {\n      return;\n    }\n\n    if (msg.channel.endsWith(\"_deals\")) {\n      // trades are send in descendinging order\n      // out library standardize to asc order so perform a reverse\n      const data = msg.data.slice().reverse();\n\n      for (const datum of data) {\n        const market = this._tradeSubs.get(datum.pair);\n\n        if (!market) return;\n\n        const trade = this._constructTradesFromMessage(datum, market);\n\n        this.emit(\"trade\", trade, market);\n      }\n\n      return;\n    } // tickers\n\n\n    if (msg.channel.endsWith(\"_ticker\")) {\n      const market = this._tickerSubs.get(msg.data.pair);\n\n      if (!market) return;\n\n      const ticker = this._constructTicker(msg, market);\n\n      this.emit(\"ticker\", ticker, market);\n      return;\n    } // l2 updates\n\n\n    if (msg.channel.endsWith(\"depth\")) {\n      const remote_id = msg.data.pair;\n\n      const market = this._level2SnapshotSubs.get(remote_id) || this._level2UpdateSubs.get(remote_id);\n\n      if (!market) return;\n\n      const snapshot = this._constructLevel2Snapshot(msg, market);\n\n      this.emit(\"l2snapshot\", snapshot, market);\n      return;\n    } // candle\n\n\n    if (msg.channel.endsWith(`kline_${candlePeriod(this.candlePeriod)}`)) {\n      // bibox_sub_spot_BTC_USDT_kline_1min\n      const remote_id = msg.channel.replace(\"bibox_sub_spot_\", \"\").replace(`_kline_${candlePeriod(this.candlePeriod)}`, \"\");\n\n      const market = this._candleSubs.get(remote_id);\n\n      if (!market) return;\n\n      for (const datum of msg.data) {\n        const candle = this._constructCandle(datum);\n\n        this.emit(\"candle\", candle, market);\n      }\n    }\n  }\n  /*\n  Constructs a ticker from the source\n  {\n    channel: 'bibox_sub_spot_BIX_BTC_ticker',\n    binary: 1,\n    data_type: 1,\n    data:\n    { last: '0.00003573',\n      buy: '0.00003554',\n      sell: '0.00003589',\n      base_last_cny: '0.86774973',\n      last_cny: '0.86',\n      buy_amount: '6.1867',\n      percent: '-1.68%',\n      pair: 'BIX_BTC',\n      high: '0.00003700',\n      vol: '737995',\n      last_usd: '0.12',\n      low: '0.00003535',\n      sell_amount: '880.0475',\n      timestamp: 1547546988399 }\n    }\n  */\n\n\n  _constructTicker(msg, market) {\n    let {\n      last,\n      buy,\n      sell,\n      vol,\n      percent,\n      low,\n      high,\n      timestamp\n    } = msg.data;\n    percent = percent.replace(/%|\\+/g, \"\");\n    const change = parseFloat(last) * parseFloat(percent) / 100;\n    const open = parseFloat(last) - change;\n    return new Ticker_1.Ticker({\n      exchange: \"Bibox\",\n      base: market.base,\n      quote: market.quote,\n      timestamp,\n      last,\n      open: open.toFixed(8),\n      high: high,\n      low: low,\n      volume: vol,\n      change: change.toFixed(8),\n      changePercent: percent,\n      bid: buy,\n      ask: sell\n    });\n  }\n  /*\n  Construct a trade\n  {\n    channel: 'bibox_sub_spot_BIX_BTC_deals',\n    binary: '1',\n    data_type: 1,\n    data:\n    [ { pair: 'BIX_BTC',\n        time: 1547544945204,\n        price: 0.0000359,\n        amount: 6.1281,\n        side: 2,\n        id: 189765713 } ]\n  }\n  */\n\n\n  _constructTradesFromMessage(datum, market) {\n    let {\n      time,\n      price,\n      amount,\n      side,\n      id\n    } = datum;\n    side = side === 1 ? \"buy\" : \"sell\";\n    return new Trade_1.Trade({\n      exchange: \"Bibox\",\n      base: market.base,\n      quote: market.quote,\n      tradeId: id,\n      side,\n      unix: time,\n      price,\n      amount\n    });\n  }\n  /**\n  {\n    channel: 'bibox_sub_spot_BTC_USDT_kline_1min',\n    binary: 1,\n    data_type: 1,\n    data: [\n      {\n        time: 1597259460000,\n        open: '11521.38000000',\n        high: '11540.58990000',\n        low: '11521.28990000',\n        close: '11540.56990000',\n        vol: '11.24330000'\n      },\n      {\n        time: 1597259520000,\n        open: '11540.55990000',\n        high: '11540.58990000',\n        low: '11533.13000000',\n        close: '11536.83990000',\n        vol: '10.88200000'\n      }\n    ]\n  }\n  */\n\n\n  _constructCandle(datum) {\n    return new Candle_1.Candle(datum.time, datum.open, datum.high, datum.low, datum.close, datum.vol);\n  }\n  /* Converts from a raw message\n  {\n      \"binary\": 0,\n      \"channel\": \"ok_sub_spot_bch_btc_depth\",\n      \"data\": { update_time: 1547549824601,\n          asks:\n          [ { volume: '433.588', price: '0.00003575' },\n            { volume: '1265.6753', price: '0.00003576' },\n               ..\n            { volume: '69.5745', price: '0.000041' },\n            { volume: '5.277', price: '0.00004169' },\n            ... 100 more items ],\n          bids:\n          [ { volume: '6.1607', price: '0.00003571' },\n            { volume: '704.8954', price: '0.00003538' },\n               ..\n            { volume: '155000', price: '2e-8' },\n            { volume: '8010000', price: '1e-8' } ],\n          pair: 'BIX_BTC' }\n  }\n  */\n\n\n  _constructLevel2Snapshot(msg, market) {\n    const asks = msg.data.asks.map(p => new Level2Point_1.Level2Point(p.price, p.volume));\n    const bids = msg.data.bids.map(p => new Level2Point_1.Level2Point(p.price, p.volume));\n    return new Level2Snapshots_1.Level2Snapshot({\n      exchange: \"Bibox\",\n      base: market.base,\n      quote: market.quote,\n      timestampMs: msg.data.update_time,\n      asks,\n      bids\n    });\n  }\n\n}\n\nexports.BiboxBasicClient = BiboxBasicClient;\n\nfunction candlePeriod(period) {\n  switch (period) {\n    case CandlePeriod_1.CandlePeriod._1m:\n      return \"1min\";\n\n    case CandlePeriod_1.CandlePeriod._5m:\n      return \"5min\";\n\n    case CandlePeriod_1.CandlePeriod._15m:\n      return \"15min\";\n\n    case CandlePeriod_1.CandlePeriod._30m:\n      return \"30min\";\n\n    case CandlePeriod_1.CandlePeriod._1h:\n      return \"1hour\";\n\n    case CandlePeriod_1.CandlePeriod._2h:\n      return \"2hour\";\n\n    case CandlePeriod_1.CandlePeriod._4h:\n      return \"4hour\";\n\n    case CandlePeriod_1.CandlePeriod._6h:\n      return \"6hour\";\n\n    case CandlePeriod_1.CandlePeriod._12h:\n      return \"12hour\";\n\n    case CandlePeriod_1.CandlePeriod._1d:\n      return \"day\";\n\n    case CandlePeriod_1.CandlePeriod._1w:\n      return \"week\";\n  }\n}","map":{"version":3,"sources":["/Users/Derek/workspace/crypto-visualizer/node_modules/ccxws/src/exchanges/BiboxClient.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable prefer-const */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-floating-promises */\n/* eslint-disable @typescript-eslint/restrict-plus-operands */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/require-await */\n\nimport zlib from \"zlib\";\nimport { IClient } from \"../IClient\";\nimport { EventEmitter } from \"events\";\nimport { Watcher } from \"../Watcher\";\nimport { BasicClient } from \"../BasicClient\";\nimport { Ticker } from \"../Ticker\";\nimport { Trade } from \"../Trade\";\nimport { Level2Point } from \"../Level2Point\";\nimport { Level2Snapshot } from \"../Level2Snapshots\";\nimport { Candle } from \"../Candle\";\nimport { SubscriptionType } from \"../SubscriptionType\";\nimport { CandlePeriod } from \"../CandlePeriod\";\nimport { throttle } from \"../flowcontrol/Throttle\";\nimport { wait } from \"../Util\";\nimport { Market } from \"../Market\";\nimport { CancelableFn } from \"../flowcontrol/Fn\";\nimport { NotImplementedAsyncFn, NotImplementedFn } from \"../NotImplementedFn\";\n\nexport type BatchedClient = IClient & {\n    parent?: IClient;\n    subCount?: number;\n};\n\nexport class BiboxClient extends EventEmitter implements IClient {\n    public readonly throttleMs: number;\n    public readonly timeoutMs: number;\n    public readonly subsPerClient: number;\n    public readonly options: any;\n\n    public readonly hasTickers: boolean;\n    public readonly hasTrades: boolean;\n    public readonly hasCandles: boolean;\n    public readonly hasLevel2Snapshots: boolean;\n    public readonly hasLevel2Updates: boolean;\n    public readonly hasLevel3Snapshots: boolean;\n    public readonly hasLevel3Updates: boolean;\n\n    public candlePeriod: CandlePeriod;\n\n    protected _subClients: Map<string, BiboxBasicClient>;\n    protected _clients: BiboxBasicClient[];\n    protected _subscribe: CancelableFn;\n\n    public subscribeLevel2Updates = NotImplementedFn;\n    public unsubscribeLevel2Updates = NotImplementedAsyncFn;\n    public subscribeLevel3Snapshots = NotImplementedFn;\n    public unsubscribeLevel3Snapshots = NotImplementedAsyncFn;\n    public subscribeLevel3Updates = NotImplementedFn;\n    public unsubscribeLevel3Updates = NotImplementedFn;\n\n    /**\n    Bibox allows listening to multiple markets on the same\n    socket. Unfortunately, they throw errors if you subscribe\n    to too more than 20 markets at a time re:\n    https://github.com/Biboxcom/API_Docs_en/wiki/WS_request#1-access-to-the-url\n    This makes like hard and we need to batch connections, which\n    is why we can't use the BasicMultiClient.\n   */\n    constructor(options?: any) {\n        super();\n\n        /**\n        Stores the client used for each subscription request with teh\n        key: remoteId_subType\n        The value is the underlying client that is used.\n       */\n        this._subClients = new Map();\n\n        /**\n        List of all active clients. Clients will be removed when all\n        subscriptions have vanished.\n       */\n        this._clients = [];\n\n        this.options = options;\n        this.hasTickers = true;\n        this.hasTrades = true;\n        this.hasCandles = true;\n        this.hasLevel2Snapshots = true;\n        this.hasLevel2Updates = false;\n        this.hasLevel3Snapshots = false;\n        this.hasLevel3Updates = false;\n        this.subsPerClient = 20;\n        this.throttleMs = 200;\n        this._subscribe = throttle(this.__subscribe.bind(this), this.throttleMs);\n        this.candlePeriod = CandlePeriod._1m;\n    }\n\n    public subscribeTicker(market: Market) {\n        this._subscribe(market, SubscriptionType.ticker);\n    }\n\n    public async unsubscribeTicker(market) {\n        this._unsubscribe(market, SubscriptionType.ticker);\n    }\n\n    public subscribeTrades(market) {\n        this._subscribe(market, SubscriptionType.trade);\n    }\n\n    public unsubscribeTrades(market) {\n        this._unsubscribe(market, SubscriptionType.trade);\n    }\n\n    public subscribeCandles(market) {\n        this._subscribe(market, SubscriptionType.candle);\n    }\n\n    public async unsubscribeCandles(market) {\n        this._unsubscribe(market, SubscriptionType.candle);\n    }\n\n    public async subscribeLevel2Snapshots(market) {\n        this._subscribe(market, SubscriptionType.level2snapshot);\n    }\n\n    public async unsubscribeLevel2Snapshots(market) {\n        this._unsubscribe(market, SubscriptionType.level2snapshot);\n    }\n\n    public close() {\n        this._subscribe.cancel();\n\n        for (const client of this._clients) {\n            client.close();\n        }\n    }\n\n    public async reconnect() {\n        for (const client of this._clients) {\n            client.reconnect();\n            await wait(this.timeoutMs);\n        }\n    }\n\n    protected __subscribe(market: Market, subscriptionType: SubscriptionType) {\n        // construct the subscription key from the remote_id and the type\n        // of subscription being performed\n        const subKey = market.id + \"_\" + subscriptionType;\n\n        // try to find the subscription client from the existing lookup\n        let client = this._subClients.get(subKey);\n\n        // if we haven't seen this market sub before first try\n        // to find an available existing client\n        if (!client) {\n            // first try to find a client that has less than 20 subscriptions...\n            client = this._clients.find(p => p.subCount < this.subsPerClient);\n\n            // make sure we set the value\n            this._subClients.set(subKey, client);\n        }\n\n        // if we were unable to find any avaialble clients, we will need\n        // to create a new client.\n        if (!client) {\n            // construct a new client\n            client = new BiboxBasicClient(this.options);\n\n            // set properties\n            client.parent = this;\n\n            // wire up the events to pass through\n            client.on(\"connecting\", () => this.emit(\"connecting\", market, subscriptionType));\n            client.on(\"connected\", () => this.emit(\"connected\", market, subscriptionType));\n            client.on(\"disconnected\", () => this.emit(\"disconnected\", market, subscriptionType));\n            client.on(\"reconnecting\", () => this.emit(\"reconnecting\", market, subscriptionType));\n            client.on(\"closing\", () => this.emit(\"closing\", market, subscriptionType));\n            client.on(\"closed\", () => this.emit(\"closed\", market, subscriptionType));\n            client.on(\"ticker\", (ticker, market) => this.emit(\"ticker\", ticker, market));\n            client.on(\"trade\", (trade, market) => this.emit(\"trade\", trade, market));\n            client.on(\"candle\", (candle, market) => this.emit(\"candle\", candle, market));\n            client.on(\"l2snapshot\", (l2snapshot, market) =>\n                this.emit(\"l2snapshot\", l2snapshot, market),\n            );\n            client.on(\"error\", err => this.emit(\"error\", err));\n\n            // push it into the list of clients\n            this._clients.push(client);\n\n            // make sure we set the value\n            this._subClients.set(subKey, client);\n        }\n\n        // now that we have a client, call the sub method, which\n        // should be an idempotent method, so no harm in calling it again\n        switch (subscriptionType) {\n            case SubscriptionType.ticker:\n                client.subscribeTicker(market);\n                break;\n            case SubscriptionType.trade:\n                client.subscribeTrades(market);\n                break;\n            case SubscriptionType.candle:\n                client.subscribeCandles(market);\n                break;\n            case SubscriptionType.level2snapshot:\n                client.subscribeLevel2Snapshots(market);\n                break;\n        }\n    }\n\n    protected _unsubscribe(market: Market, subscriptionType: SubscriptionType) {\n        // construct the subscription key from the remote_id and the type\n        // of subscription being performed\n        const subKey = market.id + \"_\" + subscriptionType;\n\n        // find the client\n        const client = this._subClients.get(subKey);\n\n        // abort if nothign to do\n        if (!client) return;\n\n        // perform the unsubscribe operation\n        switch (subscriptionType) {\n            case SubscriptionType.ticker:\n                client.unsubscribeTicker(market);\n                break;\n            case SubscriptionType.trade:\n                client.unsubscribeTrades(market);\n                break;\n            case SubscriptionType.candle:\n                client.unsubscribeCandles(market);\n                break;\n            case SubscriptionType.level2snapshot:\n                client.unsubscribeLevel2Snapshots(market);\n                break;\n        }\n\n        // remove the client if nothing left to do\n        if (client.subCount === 0) {\n            client.close();\n            const idx = this._clients.indexOf(client);\n            this._clients.splice(idx, 1);\n        }\n    }\n}\n\nexport class BiboxBasicClient extends BasicClient {\n    public subCount: number;\n    public parent: BiboxClient;\n\n    protected _sendSubLevel2Updates = NotImplementedFn;\n    protected _sendUnsubLevel2Updates = NotImplementedAsyncFn;\n    protected _sendSubLevel3Snapshots = NotImplementedFn;\n    protected _sendUnsubLevel3Snapshots = NotImplementedAsyncFn;\n    protected _sendSubLevel3Updates = NotImplementedFn;\n    protected _sendUnsubLevel3Updates = NotImplementedAsyncFn;\n\n    /**\n    Manages connections for a single market. A single\n    socket is only allowed to work for 20 markets.\n   */\n    constructor({ wssPath = \"wss://push.bibox.com\", watcherMs = 600 * 1000 } = {}) {\n        super(wssPath, \"Bibox\");\n        this._watcher = new Watcher(this, watcherMs);\n        this.hasTickers = true;\n        this.hasTrades = true;\n        this.hasCandles = true;\n        this.hasLevel2Snapshots = true;\n        this.subCount = 0;\n    }\n\n    public get candlePeriod(): CandlePeriod {\n        return this.parent.candlePeriod;\n    }\n\n    /**\n    Server will occassionally send ping messages. Client is expected\n    to respond with a pong message that matches the identifier.\n    If client fails to do this, server will abort connection after\n    second attempt.\n   */\n    protected _sendPong(id) {\n        this._wss.send(JSON.stringify({ pong: id }));\n    }\n\n    protected _sendSubTicker(remote_id: string) {\n        this.subCount++;\n        this._wss.send(\n            JSON.stringify({\n                event: \"addChannel\",\n                channel: `bibox_sub_spot_${remote_id}_ticker`,\n            }),\n        );\n    }\n\n    protected async _sendUnsubTicker(remote_id: string) {\n        this.subCount--;\n        this._wss.send(\n            JSON.stringify({\n                event: \"removeChannel\",\n                channel: `bibox_sub_spot_${remote_id}_ticker`,\n            }),\n        );\n    }\n\n    protected async _sendSubTrades(remote_id: string) {\n        this.subCount++;\n        this._wss.send(\n            JSON.stringify({\n                event: \"addChannel\",\n                channel: `bibox_sub_spot_${remote_id}_deals`,\n            }),\n        );\n    }\n\n    protected _sendUnsubTrades(remote_id: string) {\n        this.subCount--;\n        this._wss.send(\n            JSON.stringify({\n                event: \"removeChannel\",\n                channel: `bibox_sub_spot_${remote_id}_deals`,\n            }),\n        );\n    }\n\n    protected _sendSubCandles(remote_id) {\n        this.subCount++;\n        this._wss.send(\n            JSON.stringify({\n                event: \"addChannel\",\n                channel: `bibox_sub_spot_${remote_id}_kline_${candlePeriod(this.candlePeriod)}`,\n            }),\n        );\n    }\n\n    protected async _sendUnsubCandles(remote_id) {\n        this.subCount--;\n        this._wss.send(\n            JSON.stringify({\n                event: \"removeChannel\",\n                channel: `bibox_sub_spot_${remote_id}_kline_${candlePeriod(this.candlePeriod)}`,\n            }),\n        );\n    }\n\n    protected async _sendSubLevel2Snapshots(remote_id) {\n        this.subCount++;\n        this._wss.send(\n            JSON.stringify({\n                event: \"addChannel\",\n                channel: `bibox_sub_spot_${remote_id}_depth`,\n            }),\n        );\n    }\n\n    protected async _sendUnsubLevel2Snapshots(remote_id) {\n        this.subCount--;\n        this._wss.send(\n            JSON.stringify({\n                event: \"removeChannel\",\n                channel: `bibox_sub_spot_${remote_id}_depth`,\n            }),\n        );\n    }\n\n    /**\n    Message usually arives as a string, that must first be converted\n    to JSON. Then we can process each message in the payload and\n    perform gunzip on the data.\n   */\n    protected _onMessage(raw: any) {\n        const msgs = typeof raw == \"string\" ? JSON.parse(raw) : raw;\n        if (Array.isArray(msgs)) {\n            for (const msg of msgs) {\n                this._processsMessage(msg);\n            }\n        } else {\n            this._processsMessage(msgs);\n        }\n    }\n\n    /**\n    Process the individaul message that was sent from the server.\n    Message will be informat:\n\n    {\n      channel: 'bibox_sub_spot_BTC_USDT_deals',\n      binary: '1',\n      data_type: 1,\n      data:\n        'H4sIAAAAAAAA/xTLMQ6CUAyA4bv8c0Ne4RWeHdUbiJMxhghDB5QgTsa7Gw/wXT4sQ6w4+/5wO5+OPcIW84SrWdPtsllbrAjLGvcJJ6cmVZoNYZif78eGo1UqjSK8YvxLIUa8bjWnrtbyvf4CAAD//1PFt6BnAAAA'\n    }\n   */\n    protected _processsMessage(msg: any) {\n        // if we detect gzip data, we need to process it\n        if (msg.binary == 1) {\n            const buffer = zlib.gunzipSync(Buffer.from(msg.data, \"base64\"));\n            msg.data = JSON.parse(buffer.toString());\n        }\n\n        // server will occassionally send a ping message and client\n        // must respon with appropriate identifier\n        if (msg.ping) {\n            this._sendPong(msg.ping);\n            return;\n        }\n\n        // watch for error messages\n        if (msg.error) {\n            const err = new Error(msg.error);\n            err.message = msg;\n            this.emit(\"error\", err);\n            return;\n        }\n\n        if (!msg.channel) {\n            return;\n        }\n\n        if (msg.channel.endsWith(\"_deals\")) {\n            // trades are send in descendinging order\n            // out library standardize to asc order so perform a reverse\n            const data = msg.data.slice().reverse();\n            for (const datum of data) {\n                const market = this._tradeSubs.get(datum.pair);\n                if (!market) return;\n\n                const trade = this._constructTradesFromMessage(datum, market);\n                this.emit(\"trade\", trade, market);\n            }\n            return;\n        }\n\n        // tickers\n        if (msg.channel.endsWith(\"_ticker\")) {\n            const market = this._tickerSubs.get(msg.data.pair);\n            if (!market) return;\n\n            const ticker = this._constructTicker(msg, market);\n            this.emit(\"ticker\", ticker, market);\n            return;\n        }\n\n        // l2 updates\n        if (msg.channel.endsWith(\"depth\")) {\n            const remote_id = msg.data.pair;\n            const market =\n                this._level2SnapshotSubs.get(remote_id) || this._level2UpdateSubs.get(remote_id);\n            if (!market) return;\n\n            const snapshot = this._constructLevel2Snapshot(msg, market);\n            this.emit(\"l2snapshot\", snapshot, market);\n            return;\n        }\n\n        // candle\n        if (msg.channel.endsWith(`kline_${candlePeriod(this.candlePeriod)}`)) {\n            // bibox_sub_spot_BTC_USDT_kline_1min\n            const remote_id = msg.channel\n                .replace(\"bibox_sub_spot_\", \"\")\n                .replace(`_kline_${candlePeriod(this.candlePeriod)}`, \"\");\n\n            const market = this._candleSubs.get(remote_id);\n            if (!market) return;\n\n            for (const datum of msg.data) {\n                const candle = this._constructCandle(datum);\n                this.emit(\"candle\", candle, market);\n            }\n        }\n    }\n\n    /*\n    Constructs a ticker from the source\n    {\n      channel: 'bibox_sub_spot_BIX_BTC_ticker',\n      binary: 1,\n      data_type: 1,\n      data:\n      { last: '0.00003573',\n        buy: '0.00003554',\n        sell: '0.00003589',\n        base_last_cny: '0.86774973',\n        last_cny: '0.86',\n        buy_amount: '6.1867',\n        percent: '-1.68%',\n        pair: 'BIX_BTC',\n        high: '0.00003700',\n        vol: '737995',\n        last_usd: '0.12',\n        low: '0.00003535',\n        sell_amount: '880.0475',\n        timestamp: 1547546988399 }\n      }\n  */\n    protected _constructTicker(msg: any, market: Market) {\n        let { last, buy, sell, vol, percent, low, high, timestamp } = msg.data;\n\n        percent = percent.replace(/%|\\+/g, \"\");\n        const change = (parseFloat(last) * parseFloat(percent)) / 100;\n        const open = parseFloat(last) - change;\n\n        return new Ticker({\n            exchange: \"Bibox\",\n            base: market.base,\n            quote: market.quote,\n            timestamp,\n            last,\n            open: open.toFixed(8),\n            high: high,\n            low: low,\n            volume: vol,\n            change: change.toFixed(8),\n            changePercent: percent,\n            bid: buy,\n            ask: sell,\n        });\n    }\n\n    /*\n    Construct a trade\n    {\n      channel: 'bibox_sub_spot_BIX_BTC_deals',\n      binary: '1',\n      data_type: 1,\n      data:\n      [ { pair: 'BIX_BTC',\n          time: 1547544945204,\n          price: 0.0000359,\n          amount: 6.1281,\n          side: 2,\n          id: 189765713 } ]\n    }\n  */\n    protected _constructTradesFromMessage(datum: any, market: Market) {\n        let { time, price, amount, side, id } = datum;\n\n        side = side === 1 ? \"buy\" : \"sell\";\n        return new Trade({\n            exchange: \"Bibox\",\n            base: market.base,\n            quote: market.quote,\n            tradeId: id,\n            side,\n            unix: time,\n            price,\n            amount,\n        });\n    }\n\n    /**\n   {\n      channel: 'bibox_sub_spot_BTC_USDT_kline_1min',\n      binary: 1,\n      data_type: 1,\n      data: [\n        {\n          time: 1597259460000,\n          open: '11521.38000000',\n          high: '11540.58990000',\n          low: '11521.28990000',\n          close: '11540.56990000',\n          vol: '11.24330000'\n        },\n        {\n          time: 1597259520000,\n          open: '11540.55990000',\n          high: '11540.58990000',\n          low: '11533.13000000',\n          close: '11536.83990000',\n          vol: '10.88200000'\n        }\n      ]\n    }\n   */\n    protected _constructCandle(datum: any) {\n        return new Candle(datum.time, datum.open, datum.high, datum.low, datum.close, datum.vol);\n    }\n\n    /* Converts from a raw message\n    {\n        \"binary\": 0,\n        \"channel\": \"ok_sub_spot_bch_btc_depth\",\n        \"data\": { update_time: 1547549824601,\n            asks:\n            [ { volume: '433.588', price: '0.00003575' },\n              { volume: '1265.6753', price: '0.00003576' },\n                 ..\n              { volume: '69.5745', price: '0.000041' },\n              { volume: '5.277', price: '0.00004169' },\n              ... 100 more items ],\n            bids:\n            [ { volume: '6.1607', price: '0.00003571' },\n              { volume: '704.8954', price: '0.00003538' },\n                 ..\n              { volume: '155000', price: '2e-8' },\n              { volume: '8010000', price: '1e-8' } ],\n            pair: 'BIX_BTC' }\n    }\n  */\n    protected _constructLevel2Snapshot(msg: any, market: Market) {\n        const asks = msg.data.asks.map(p => new Level2Point(p.price, p.volume));\n        const bids = msg.data.bids.map(p => new Level2Point(p.price, p.volume));\n        return new Level2Snapshot({\n            exchange: \"Bibox\",\n            base: market.base,\n            quote: market.quote,\n            timestampMs: msg.data.update_time,\n            asks,\n            bids,\n        });\n    }\n}\n\nfunction candlePeriod(period) {\n    switch (period) {\n        case CandlePeriod._1m:\n            return \"1min\";\n        case CandlePeriod._5m:\n            return \"5min\";\n        case CandlePeriod._15m:\n            return \"15min\";\n        case CandlePeriod._30m:\n            return \"30min\";\n        case CandlePeriod._1h:\n            return \"1hour\";\n        case CandlePeriod._2h:\n            return \"2hour\";\n        case CandlePeriod._4h:\n            return \"4hour\";\n        case CandlePeriod._6h:\n            return \"6hour\";\n        case CandlePeriod._12h:\n            return \"12hour\";\n        case CandlePeriod._1d:\n            return \"day\";\n        case CandlePeriod._1w:\n            return \"week\";\n    }\n}\n"]},"metadata":{},"sourceType":"script"}