{"ast":null,"code":"\"use strict\";\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SmartWss = void 0;\n\nconst events_1 = require(\"events\");\n\nconst ws_1 = __importDefault(require(\"ws\"));\n\nconst Util_1 = require(\"./Util\");\n\nclass SmartWss extends events_1.EventEmitter {\n  constructor(wssPath) {\n    super();\n    this.wssPath = wssPath;\n    this._retryTimeoutMs = 15000;\n    this._connected = false;\n  }\n  /**\n   * Gets if the socket is currently connected\n   */\n\n\n  get isConnected() {\n    return this._connected;\n  }\n  /**\n   * Attempts to connect\n   */\n\n\n  async connect() {\n    await this._attemptConnect();\n  }\n  /**\n   * Closes the connection\n   */\n\n\n  close() {\n    this.emit(\"closing\");\n\n    if (this._wss) {\n      this._wss.removeAllListeners();\n\n      this._wss.on(\"close\", () => this.emit(\"closed\"));\n\n      this._wss.on(\"error\", err => {\n        if (err.message !== \"WebSocket was closed before the connection was established\") return;\n        this.emit(\"error\", err);\n      });\n\n      this._wss.close();\n    }\n  }\n  /**\n   * Sends the data if the socket is currently connected.\n   * Otherwise the consumer needs to retry to send the information\n   * when the socket is connected.\n   */\n\n\n  send(data) {\n    if (this._connected) {\n      try {\n        this._wss.send(data);\n      } catch (e) {\n        this.emit(\"error\", e);\n      }\n    }\n  } /////////////////////////\n\n  /**\n   * Attempts a connection and will either fail or timeout otherwise.\n   */\n\n\n  _attemptConnect() {\n    return new Promise(resolve => {\n      const wssPath = this.wssPath;\n      this.emit(\"connecting\");\n      this._wss = new ws_1.default(wssPath, {\n        perMessageDeflate: false,\n        handshakeTimeout: 15000\n      });\n\n      this._wss.on(\"open\", () => {\n        this._connected = true;\n        this.emit(\"open\"); // deprecated\n\n        this.emit(\"connected\");\n        resolve();\n      });\n\n      this._wss.on(\"close\", () => this._closeCallback());\n\n      this._wss.on(\"error\", err => this.emit(\"error\", err));\n\n      this._wss.on(\"message\", msg => this.emit(\"message\", msg));\n    });\n  }\n  /**\n   * Handles the closing event by reconnecting\n   */\n\n\n  _closeCallback() {\n    this._connected = false;\n    this._wss = null;\n    this.emit(\"disconnected\");\n    void this._retryConnect();\n  }\n  /**\n   * Perform reconnection after the timeout period\n   * and will loop on hard failures\n   */\n\n\n  async _retryConnect() {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      try {\n        await (0, Util_1.wait)(this._retryTimeoutMs);\n        await this._attemptConnect();\n        return;\n      } catch (ex) {\n        this.emit(\"error\", ex);\n      }\n    }\n  }\n\n}\n\nexports.SmartWss = SmartWss;","map":{"version":3,"sources":["/Users/Derek/workspace/crypto-visualizer/node_modules/ccxws/src/SmartWss.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\nimport { EventEmitter } from \"events\";\nimport WebSocket from \"ws\";\nimport { wait } from \"./Util\";\n\nexport class SmartWss extends EventEmitter {\n    private _retryTimeoutMs: number;\n    private _connected: boolean;\n    private _wss: any;\n\n    constructor(readonly wssPath: string) {\n        super();\n        this._retryTimeoutMs = 15000;\n        this._connected = false;\n    }\n\n    /**\n     * Gets if the socket is currently connected\n     */\n    public get isConnected() {\n        return this._connected;\n    }\n\n    /**\n     * Attempts to connect\n     */\n    public async connect(): Promise<void> {\n        await this._attemptConnect();\n    }\n\n    /**\n     * Closes the connection\n     */\n    public close(): void {\n        this.emit(\"closing\");\n        if (this._wss) {\n            this._wss.removeAllListeners();\n            this._wss.on(\"close\", () => this.emit(\"closed\"));\n            this._wss.on(\"error\", err => {\n                if (err.message !== \"WebSocket was closed before the connection was established\")\n                    return;\n                this.emit(\"error\", err);\n            });\n            this._wss.close();\n        }\n    }\n\n    /**\n     * Sends the data if the socket is currently connected.\n     * Otherwise the consumer needs to retry to send the information\n     * when the socket is connected.\n     */\n    public send(data: string) {\n        if (this._connected) {\n            try {\n                this._wss.send(data);\n            } catch (e) {\n                this.emit(\"error\", e);\n            }\n        }\n    }\n\n    /////////////////////////\n\n    /**\n     * Attempts a connection and will either fail or timeout otherwise.\n     */\n    private _attemptConnect(): Promise<void> {\n        return new Promise(resolve => {\n            const wssPath = this.wssPath;\n            this.emit(\"connecting\");\n            this._wss = new WebSocket(wssPath, {\n                perMessageDeflate: false,\n                handshakeTimeout: 15000,\n            });\n            this._wss.on(\"open\", () => {\n                this._connected = true;\n                this.emit(\"open\"); // deprecated\n                this.emit(\"connected\");\n                resolve();\n            });\n            this._wss.on(\"close\", () => this._closeCallback());\n            this._wss.on(\"error\", err => this.emit(\"error\", err));\n            this._wss.on(\"message\", msg => this.emit(\"message\", msg));\n        });\n    }\n\n    /**\n     * Handles the closing event by reconnecting\n     */\n    private _closeCallback(): void {\n        this._connected = false;\n        this._wss = null;\n        this.emit(\"disconnected\");\n        void this._retryConnect();\n    }\n\n    /**\n     * Perform reconnection after the timeout period\n     * and will loop on hard failures\n     */\n    private async _retryConnect(): Promise<void> {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            try {\n                await wait(this._retryTimeoutMs);\n                await this._attemptConnect();\n                return;\n            } catch (ex) {\n                this.emit(\"error\", ex);\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"script"}