{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GeminiClient = void 0;\n/* eslint-disable @typescript-eslint/member-ordering */\n\n/* eslint-disable @typescript-eslint/no-floating-promises */\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\nconst events_1 = require(\"events\");\n\nconst Level2Point_1 = require(\"../Level2Point\");\n\nconst Level2Snapshots_1 = require(\"../Level2Snapshots\");\n\nconst Level2Update_1 = require(\"../Level2Update\");\n\nconst NotImplementedFn_1 = require(\"../NotImplementedFn\");\n\nconst SmartWss_1 = require(\"../SmartWss\");\n\nconst Ticker_1 = require(\"../Ticker\");\n\nconst Trade_1 = require(\"../Trade\");\n\nclass GeminiClient extends events_1.EventEmitter {\n  constructor() {\n    let {\n      wssPath,\n      watcherMs = 30000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.subscribeCandles = NotImplementedFn_1.NotImplementedFn;\n    this.unsubscribeCandles = NotImplementedFn_1.NotImplementedFn;\n    this.subscribeLevel2Snapshots = NotImplementedFn_1.NotImplementedFn;\n    this.unsubscribeLevel2Snapshots = NotImplementedFn_1.NotImplementedFn;\n    this.subscribeLevel3Snapshots = NotImplementedFn_1.NotImplementedFn;\n    this.unsubscribeLevel3Snapshots = NotImplementedFn_1.NotImplementedFn;\n    this.subscribeLevel3Updates = NotImplementedFn_1.NotImplementedFn;\n    this.unsubscribeLevel3Updates = NotImplementedFn_1.NotImplementedFn;\n    this.wssPath = wssPath;\n    this.name = \"Gemini\";\n    this._subscriptions = new Map();\n    this.reconnectIntervalMs = watcherMs;\n    this.tickersCache = new Map(); // key-value pairs of <market_id>: Ticker\n\n    this.hasTickers = true;\n    this.hasTrades = true;\n    this.hasCandles = false;\n    this.hasLevel2Snapshots = false;\n    this.hasLevel2Updates = true;\n    this.hasLevel3Snapshots = false;\n    this.hasLevel3Updates = false;\n  }\n\n  reconnect() {\n    for (const subscription of this._subscriptions.values()) {\n      this._reconnect(subscription);\n    }\n  }\n\n  subscribeTrades(market) {\n    this._subscribe(market, \"trades\");\n  }\n\n  unsubscribeTrades(market) {\n    this._unsubscribe(market, \"trades\");\n  }\n\n  subscribeLevel2Updates(market) {\n    this._subscribe(market, \"level2updates\");\n  }\n\n  unsubscribeLevel2Updates(market) {\n    this._unsubscribe(market, \"level2updates\");\n\n    return;\n  }\n\n  subscribeTicker(market) {\n    this._subscribe(market, \"tickers\");\n  }\n\n  unsubscribeTicker(market) {\n    this._unsubscribe(market, \"tickers\");\n\n    return;\n  }\n\n  close() {\n    this._close();\n  } ////////////////////////////////////////////\n  // PROTECTED\n\n\n  _subscribe(market, mode) {\n    let remote_id = market.id.toLowerCase();\n    if (mode === \"tickers\") remote_id += \"-tickers\";\n\n    let subscription = this._subscriptions.get(remote_id);\n\n    if (subscription && subscription[mode]) return;\n\n    if (!subscription) {\n      subscription = {\n        market,\n        wss: this._connect(remote_id),\n        lastMessage: undefined,\n        reconnectIntervalHandle: undefined,\n        remoteId: remote_id,\n        trades: false,\n        level2updates: false,\n        tickers: false\n      };\n\n      this._startReconnectWatcher(subscription);\n\n      this._subscriptions.set(remote_id, subscription);\n    }\n\n    subscription[mode] = true;\n  }\n\n  _unsubscribe(market, mode) {\n    let remote_id = market.id.toLowerCase();\n    if (mode === \"tickers\") remote_id += \"-tickers\";\n\n    const subscription = this._subscriptions.get(remote_id);\n\n    if (!subscription) return;\n    subscription[mode] = false;\n\n    if (!subscription.trades && !subscription.level2updates) {\n      this._close(this._subscriptions.get(remote_id));\n\n      this._subscriptions.delete(remote_id);\n    }\n\n    if (mode === \"tickers\") {\n      this.tickersCache.delete(market.id);\n    }\n  }\n  /** Connect to the websocket stream by constructing a path from\n   * the subscribed markets.\n   */\n\n\n  _connect(remote_id) {\n    const forTickers = remote_id.endsWith(\"-tickers\");\n    const wssPath = this.wssPath || forTickers ? `wss://api.gemini.com/v1/marketdata/${remote_id}?heartbeat=true&top_of_book=true` : `wss://api.gemini.com/v1/marketdata/${remote_id}?heartbeat=true`;\n    const wss = new SmartWss_1.SmartWss(wssPath);\n    wss.on(\"error\", err => this._onError(remote_id, err));\n    wss.on(\"connecting\", () => this._onConnecting(remote_id));\n    wss.on(\"connected\", () => this._onConnected(remote_id));\n    wss.on(\"disconnected\", () => this._onDisconnected(remote_id));\n    wss.on(\"closing\", () => this._onClosing(remote_id));\n    wss.on(\"closed\", () => this._onClosed(remote_id));\n    wss.on(\"message\", raw => {\n      try {\n        this._onMessage(remote_id, raw);\n      } catch (err) {\n        this._onError(remote_id, err);\n      }\n    });\n    wss.connect();\n    return wss;\n  }\n  /**\n   * Handles an error\n   */\n\n\n  _onError(remote_id, err) {\n    this.emit(\"error\", err, remote_id);\n  }\n  /**\n   * Fires when a socket is connecting\n   */\n\n\n  _onConnecting(remote_id) {\n    this.emit(\"connecting\", remote_id);\n  }\n  /**\n   * Fires when connected\n   */\n\n\n  _onConnected(remote_id) {\n    const subscription = this._subscriptions.get(remote_id);\n\n    if (!subscription) {\n      return;\n    }\n\n    this._startReconnectWatcher(subscription);\n\n    this.emit(\"connected\", remote_id);\n  }\n  /**\n   * Fires when there is a disconnection event\n   */\n\n\n  _onDisconnected(remote_id) {\n    this._stopReconnectWatcher(this._subscriptions.get(remote_id));\n\n    this.emit(\"disconnected\", remote_id);\n  }\n  /**\n   * Fires when the underlying socket is closing\n   */\n\n\n  _onClosing(remote_id) {\n    this._stopReconnectWatcher(this._subscriptions.get(remote_id));\n\n    this.emit(\"closing\", remote_id);\n  }\n  /**\n   * Fires when the underlying socket has closed\n   */\n\n\n  _onClosed(remote_id) {\n    this.emit(\"closed\", remote_id);\n  }\n  /**\n   * Close the underlying connction, which provides a way to reset the things\n   */\n\n\n  _close(subscription) {\n    if (subscription && subscription.wss) {\n      try {\n        subscription.wss.close();\n      } catch (ex) {\n        if (ex.message === \"WebSocket was closed before the connection was established\") return;\n        this.emit(\"error\", ex);\n      }\n\n      subscription.wss = undefined;\n\n      this._stopReconnectWatcher(subscription);\n    } else {\n      this._subscriptions.forEach(sub => this._close(sub));\n\n      this._subscriptions = new Map();\n    }\n  }\n  /**\n   * Reconnects the socket\n   */\n\n\n  _reconnect(subscription) {\n    this.emit(\"reconnecting\", subscription.remoteId);\n    subscription.wss.once(\"closed\", () => {\n      subscription.wss = this._connect(subscription.remoteId);\n    });\n\n    this._close(subscription);\n  }\n  /**\n   * Starts an interval to check if a reconnction is required\n   */\n\n\n  _startReconnectWatcher(subscription) {\n    this._stopReconnectWatcher(subscription); // always clear the prior interval\n\n\n    subscription.reconnectIntervalHandle = setInterval(() => this._onReconnectCheck(subscription), this.reconnectIntervalMs);\n  }\n  /**\n   * Stops an interval to check if a reconnection is required\n   */\n\n\n  _stopReconnectWatcher(subscription) {\n    if (subscription) {\n      clearInterval(subscription.reconnectIntervalHandle);\n      subscription.reconnectIntervalHandle = undefined;\n    }\n  }\n  /**\n   * Checks if a reconnecton is required by comparing the current\n   * date to the last receieved message date\n   */\n\n\n  _onReconnectCheck(subscription) {\n    if (!subscription.lastMessage || subscription.lastMessage < Date.now() - this.reconnectIntervalMs) {\n      this._reconnect(subscription);\n    }\n  } ////////////////////////////////////////////\n  // ABSTRACT\n\n\n  _onMessage(remote_id, raw) {\n    const msg = JSON.parse(raw);\n\n    const subscription = this._subscriptions.get(remote_id);\n\n    const market = subscription.market;\n    subscription.lastMessage = Date.now();\n    if (!market) return;\n\n    if (msg.type === \"heartbeat\") {\n      // ex: '{\"type\":\"heartbeat\",\"socket_sequence\":272}'\n\n      /*\n      A few notes on heartbeats and sequenceIds taken from the Gemini docs:\n      - Ongoing order events are interspersed with heartbeats every five seconds\n      - So you can easily ensure that you are receiving all of your WebSocket messages in the expected order without any gaps, events and heartbeats contain a special sequence number.\n      - Your subscription begins - you receive your first event with socket_sequence set to a value of 0\n      - For all further messages, each message - whether a heartbeat or an event - should increase this sequence number by one.\n      - Each time you reconnect, the sequence number resets to zero.\n      - If you have multiple WebSocket connections, each will have a separate sequence number beginning with zero - make sure to keep track of each sequence number separately!\n      */\n      if (subscription.level2updates) {\n        /*\n        So when subbed to l2 updates using sequenceId, a heartbeat event will arrive which includes sequenceId.\n        You'll need to receive the heartbeat, otherwise sequence will have a gap in next l2update,\n        So emit an l2update w/no ask or bid changes, only including the sequenceId\n        */\n        const sequenceId = msg.socket_sequence;\n        this.emit(\"l2update\", this._constructL2Update([], market, sequenceId, null, null), market);\n        return;\n      }\n    }\n\n    if (msg.type === \"update\") {\n      const {\n        timestampms,\n        eventId,\n        socket_sequence\n      } = msg;\n      const sequenceId = socket_sequence; // process trades\n\n      if (subscription.trades) {\n        const events = msg.events.filter(p => p.type === \"trade\" && /ask|bid/.test(p.makerSide));\n\n        for (const event of events) {\n          const trade = this._constructTrade(event, market, timestampms);\n\n          this.emit(\"trade\", trade, market);\n        }\n\n        return;\n      } // process l2 updates\n\n\n      if (subscription.level2updates) {\n        const updates = msg.events.filter(p => p.type === \"change\");\n\n        if (socket_sequence === 0) {\n          const snapshot = this._constructL2Snapshot(updates, market, sequenceId, eventId);\n\n          this.emit(\"l2snapshot\", snapshot, market);\n        } else {\n          const update = this._constructL2Update(updates, market, sequenceId, timestampms, eventId);\n\n          this.emit(\"l2update\", update, market);\n        }\n\n        return;\n      } // process ticker\n      // tickers are processed from a seperate websocket\n\n\n      if (subscription.tickers) {\n        const ticker = this._constructTicker(msg, market);\n\n        if (ticker.last && ticker.bid && ticker.ask) {\n          this.emit(\"ticker\", ticker, market);\n        }\n\n        return;\n      }\n    }\n  }\n\n  _constructTrade(event, market, timestamp) {\n    const side = event.makerSide === \"ask\" ? \"sell\" : \"buy\";\n    const price = event.price;\n    const amount = event.amount;\n    return new Trade_1.Trade({\n      exchange: this.name,\n      base: market.base,\n      quote: market.quote,\n      tradeId: event.tid.toFixed(),\n      side,\n      unix: timestamp,\n      price,\n      amount\n    });\n  }\n\n  _constructL2Snapshot(events, market, sequenceId, eventId) {\n    const asks = [];\n    const bids = [];\n\n    for (const {\n      side,\n      price,\n      remaining,\n      reason,\n      delta\n    } of events) {\n      const update = new Level2Point_1.Level2Point(price, remaining, undefined, {\n        reason,\n        delta\n      });\n      if (side === \"ask\") asks.push(update);else bids.push(update);\n    }\n\n    return new Level2Snapshots_1.Level2Snapshot({\n      exchange: this.name,\n      base: market.base,\n      quote: market.quote,\n      sequenceId,\n      eventId,\n      asks,\n      bids\n    });\n  }\n\n  _constructL2Update(events, market, sequenceId, timestampMs, eventId) {\n    const asks = [];\n    const bids = [];\n\n    for (const {\n      side,\n      price,\n      remaining,\n      reason,\n      delta\n    } of events) {\n      const update = new Level2Point_1.Level2Point(price, remaining, undefined, {\n        reason,\n        delta\n      });\n      if (side === \"ask\") asks.push(update);else bids.push(update);\n    }\n\n    return new Level2Update_1.Level2Update({\n      exchange: this.name,\n      base: market.base,\n      quote: market.quote,\n      sequenceId,\n      eventId,\n      timestampMs,\n      asks,\n      bids\n    });\n  }\n\n  _constructTicker(msg, market) {\n    const ticker = this._getTicker(market);\n\n    for (let i = 0; i < msg.events.length; i++) {\n      const event = msg.events[i]; // asks - top_of_book in use\n\n      if (event.type === \"change\" && event.side === \"ask\") {\n        ticker.ask = event.price;\n        ticker.timestamp = msg.timestampms;\n      } // bids - top_of_book in use\n\n\n      if (event.type === \"change\" && event.side === \"bid\") {\n        ticker.bid = event.price;\n        ticker.timestamp = msg.timestampms;\n      } // attach latest trade information\n\n\n      if (event.type === \"trade\") {\n        ticker.last = event.price;\n        ticker.timestamp = msg.timestampms;\n      }\n    }\n\n    return ticker;\n  }\n  /**\n   * Ensures that a ticker for the market exists\n   * @param {*} market\n   */\n\n\n  _getTicker(market) {\n    if (!this.tickersCache.has(market.id)) {\n      this.tickersCache.set(market.id, new Ticker_1.Ticker({\n        exchange: this.name,\n        base: market.base,\n        quote: market.quote\n      }));\n    }\n\n    return this.tickersCache.get(market.id);\n  }\n\n}\n\nexports.GeminiClient = GeminiClient;","map":{"version":3,"sources":["/Users/Derek/workspace/crypto-visualizer/node_modules/ccxws/src/exchanges/Geminiclient.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/member-ordering */\n/* eslint-disable @typescript-eslint/no-floating-promises */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\nimport { EventEmitter } from \"events\";\nimport { ClientOptions } from \"../ClientOptions\";\nimport { IClient } from \"../IClient\";\nimport { Level2Point } from \"../Level2Point\";\nimport { Level2Snapshot } from \"../Level2Snapshots\";\nimport { Level2Update } from \"../Level2Update\";\nimport { Market } from \"../Market\";\nimport { NotImplementedFn } from \"../NotImplementedFn\";\nimport { SmartWss } from \"../SmartWss\";\nimport { Ticker } from \"../Ticker\";\nimport { Trade } from \"../Trade\";\n\nexport type GeminiSubscription = {\n    market: Market;\n    wss: SmartWss;\n    lastMessage: any;\n    reconnectIntervalHandle: number;\n    remoteId: string;\n    trades: boolean;\n    level2updates: boolean;\n    tickers: boolean;\n};\n\nexport class GeminiClient extends EventEmitter implements IClient {\n    public wssPath: string;\n    public name: string;\n\n    public reconnectIntervalMs: number;\n    public tickersCache: Map<string, Ticker>;\n    public readonly hasTickers: boolean;\n    public readonly hasTrades: boolean;\n    public readonly hasCandles: boolean;\n    public readonly hasLevel2Snapshots: boolean;\n    public readonly hasLevel2Updates: boolean;\n    public readonly hasLevel3Snapshots: boolean;\n    public readonly hasLevel3Updates: boolean;\n\n    protected _subscriptions: Map<string, GeminiSubscription>;\n\n    constructor({ wssPath, watcherMs = 30000 }: ClientOptions = {}) {\n        super();\n        this.wssPath = wssPath;\n        this.name = \"Gemini\";\n        this._subscriptions = new Map();\n        this.reconnectIntervalMs = watcherMs;\n        this.tickersCache = new Map(); // key-value pairs of <market_id>: Ticker\n\n        this.hasTickers = true;\n        this.hasTrades = true;\n        this.hasCandles = false;\n        this.hasLevel2Snapshots = false;\n        this.hasLevel2Updates = true;\n        this.hasLevel3Snapshots = false;\n        this.hasLevel3Updates = false;\n    }\n\n    public reconnect() {\n        for (const subscription of this._subscriptions.values()) {\n            this._reconnect(subscription);\n        }\n    }\n\n    public subscribeTrades(market: Market) {\n        this._subscribe(market, \"trades\");\n    }\n\n    public unsubscribeTrades(market: Market) {\n        this._unsubscribe(market, \"trades\");\n    }\n\n    public subscribeLevel2Updates(market: Market) {\n        this._subscribe(market, \"level2updates\");\n    }\n\n    public unsubscribeLevel2Updates(market: Market): Promise<void> {\n        this._unsubscribe(market, \"level2updates\");\n        return;\n    }\n\n    public subscribeTicker(market: Market) {\n        this._subscribe(market, \"tickers\");\n    }\n\n    public unsubscribeTicker(market: Market): Promise<void> {\n        this._unsubscribe(market, \"tickers\");\n        return;\n    }\n\n    public subscribeCandles = NotImplementedFn;\n    public unsubscribeCandles = NotImplementedFn;\n    public subscribeLevel2Snapshots = NotImplementedFn;\n    public unsubscribeLevel2Snapshots = NotImplementedFn;\n    public subscribeLevel3Snapshots = NotImplementedFn;\n    public unsubscribeLevel3Snapshots = NotImplementedFn;\n    public subscribeLevel3Updates = NotImplementedFn;\n    public unsubscribeLevel3Updates = NotImplementedFn;\n\n    public close() {\n        this._close();\n    }\n\n    ////////////////////////////////////////////\n    // PROTECTED\n\n    protected _subscribe(market: Market, mode: string) {\n        let remote_id = market.id.toLowerCase();\n        if (mode === \"tickers\") remote_id += \"-tickers\";\n\n        let subscription = this._subscriptions.get(remote_id);\n\n        if (subscription && subscription[mode]) return;\n\n        if (!subscription) {\n            subscription = {\n                market,\n                wss: this._connect(remote_id),\n                lastMessage: undefined,\n                reconnectIntervalHandle: undefined,\n                remoteId: remote_id,\n                trades: false,\n                level2updates: false,\n                tickers: false,\n            };\n\n            this._startReconnectWatcher(subscription);\n            this._subscriptions.set(remote_id, subscription);\n        }\n\n        subscription[mode] = true;\n    }\n\n    protected _unsubscribe(market: Market, mode: string) {\n        let remote_id = market.id.toLowerCase();\n        if (mode === \"tickers\") remote_id += \"-tickers\";\n        const subscription = this._subscriptions.get(remote_id);\n\n        if (!subscription) return;\n        subscription[mode] = false;\n        if (!subscription.trades && !subscription.level2updates) {\n            this._close(this._subscriptions.get(remote_id));\n            this._subscriptions.delete(remote_id);\n        }\n        if (mode === \"tickers\") {\n            this.tickersCache.delete(market.id);\n        }\n    }\n\n    /** Connect to the websocket stream by constructing a path from\n     * the subscribed markets.\n     */\n    protected _connect(remote_id: string) {\n        const forTickers = remote_id.endsWith(\"-tickers\");\n        const wssPath =\n            this.wssPath || forTickers\n                ? `wss://api.gemini.com/v1/marketdata/${remote_id}?heartbeat=true&top_of_book=true`\n                : `wss://api.gemini.com/v1/marketdata/${remote_id}?heartbeat=true`;\n\n        const wss = new SmartWss(wssPath);\n        wss.on(\"error\", err => this._onError(remote_id, err));\n        wss.on(\"connecting\", () => this._onConnecting(remote_id));\n        wss.on(\"connected\", () => this._onConnected(remote_id));\n        wss.on(\"disconnected\", () => this._onDisconnected(remote_id));\n        wss.on(\"closing\", () => this._onClosing(remote_id));\n        wss.on(\"closed\", () => this._onClosed(remote_id));\n        wss.on(\"message\", raw => {\n            try {\n                this._onMessage(remote_id, raw);\n            } catch (err) {\n                this._onError(remote_id, err);\n            }\n        });\n        wss.connect();\n        return wss;\n    }\n\n    /**\n     * Handles an error\n     */\n    protected _onError(remote_id, err) {\n        this.emit(\"error\", err, remote_id);\n    }\n\n    /**\n     * Fires when a socket is connecting\n     */\n    protected _onConnecting(remote_id) {\n        this.emit(\"connecting\", remote_id);\n    }\n\n    /**\n     * Fires when connected\n     */\n    protected _onConnected(remote_id) {\n        const subscription = this._subscriptions.get(remote_id);\n        if (!subscription) {\n            return;\n        }\n        this._startReconnectWatcher(subscription);\n        this.emit(\"connected\", remote_id);\n    }\n\n    /**\n     * Fires when there is a disconnection event\n     */\n    protected _onDisconnected(remote_id) {\n        this._stopReconnectWatcher(this._subscriptions.get(remote_id));\n        this.emit(\"disconnected\", remote_id);\n    }\n\n    /**\n     * Fires when the underlying socket is closing\n     */\n    protected _onClosing(remote_id) {\n        this._stopReconnectWatcher(this._subscriptions.get(remote_id));\n        this.emit(\"closing\", remote_id);\n    }\n\n    /**\n     * Fires when the underlying socket has closed\n     */\n    protected _onClosed(remote_id) {\n        this.emit(\"closed\", remote_id);\n    }\n\n    /**\n     * Close the underlying connction, which provides a way to reset the things\n     */\n    protected _close(subscription?: any) {\n        if (subscription && subscription.wss) {\n            try {\n                subscription.wss.close();\n            } catch (ex) {\n                if (ex.message === \"WebSocket was closed before the connection was established\")\n                    return;\n                this.emit(\"error\", ex);\n            }\n            subscription.wss = undefined;\n            this._stopReconnectWatcher(subscription);\n        } else {\n            this._subscriptions.forEach(sub => this._close(sub));\n            this._subscriptions = new Map();\n        }\n    }\n\n    /**\n     * Reconnects the socket\n     */\n    protected _reconnect(subscription) {\n        this.emit(\"reconnecting\", subscription.remoteId);\n        subscription.wss.once(\"closed\", () => {\n            subscription.wss = this._connect(subscription.remoteId);\n        });\n        this._close(subscription);\n    }\n\n    /**\n     * Starts an interval to check if a reconnction is required\n     */\n    protected _startReconnectWatcher(subscription) {\n        this._stopReconnectWatcher(subscription); // always clear the prior interval\n        subscription.reconnectIntervalHandle = setInterval(\n            () => this._onReconnectCheck(subscription),\n            this.reconnectIntervalMs,\n        );\n    }\n\n    /**\n     * Stops an interval to check if a reconnection is required\n     */\n    protected _stopReconnectWatcher(subscription) {\n        if (subscription) {\n            clearInterval(subscription.reconnectIntervalHandle);\n            subscription.reconnectIntervalHandle = undefined;\n        }\n    }\n\n    /**\n     * Checks if a reconnecton is required by comparing the current\n     * date to the last receieved message date\n     */\n    protected _onReconnectCheck(subscription) {\n        if (\n            !subscription.lastMessage ||\n            subscription.lastMessage < Date.now() - this.reconnectIntervalMs\n        ) {\n            this._reconnect(subscription);\n        }\n    }\n\n    ////////////////////////////////////////////\n    // ABSTRACT\n\n    protected _onMessage(remote_id: string, raw: string) {\n        const msg = JSON.parse(raw);\n        const subscription = this._subscriptions.get(remote_id);\n        const market = subscription.market;\n        subscription.lastMessage = Date.now();\n\n        if (!market) return;\n\n        if (msg.type === \"heartbeat\") {\n            // ex: '{\"type\":\"heartbeat\",\"socket_sequence\":272}'\n            /*\n        A few notes on heartbeats and sequenceIds taken from the Gemini docs:\n        - Ongoing order events are interspersed with heartbeats every five seconds\n        - So you can easily ensure that you are receiving all of your WebSocket messages in the expected order without any gaps, events and heartbeats contain a special sequence number.\n        - Your subscription begins - you receive your first event with socket_sequence set to a value of 0\n        - For all further messages, each message - whether a heartbeat or an event - should increase this sequence number by one.\n        - Each time you reconnect, the sequence number resets to zero.\n        - If you have multiple WebSocket connections, each will have a separate sequence number beginning with zero - make sure to keep track of each sequence number separately!\n      */\n            if (subscription.level2updates) {\n                /*\n          So when subbed to l2 updates using sequenceId, a heartbeat event will arrive which includes sequenceId.\n          You'll need to receive the heartbeat, otherwise sequence will have a gap in next l2update,\n          So emit an l2update w/no ask or bid changes, only including the sequenceId\n        */\n                const sequenceId = msg.socket_sequence;\n                this.emit(\n                    \"l2update\",\n                    this._constructL2Update([], market, sequenceId, null, null),\n                    market,\n                );\n                return;\n            }\n        }\n\n        if (msg.type === \"update\") {\n            const { timestampms, eventId, socket_sequence } = msg;\n            const sequenceId = socket_sequence;\n\n            // process trades\n            if (subscription.trades) {\n                const events = msg.events.filter(\n                    p => p.type === \"trade\" && /ask|bid/.test(p.makerSide),\n                );\n                for (const event of events) {\n                    const trade = this._constructTrade(event, market, timestampms);\n                    this.emit(\"trade\", trade, market);\n                }\n                return;\n            }\n\n            // process l2 updates\n            if (subscription.level2updates) {\n                const updates = msg.events.filter(p => p.type === \"change\");\n                if (socket_sequence === 0) {\n                    const snapshot = this._constructL2Snapshot(\n                        updates,\n                        market,\n                        sequenceId,\n                        eventId,\n                    );\n                    this.emit(\"l2snapshot\", snapshot, market);\n                } else {\n                    const update = this._constructL2Update(\n                        updates,\n                        market,\n                        sequenceId,\n                        timestampms,\n                        eventId,\n                    );\n                    this.emit(\"l2update\", update, market);\n                }\n                return;\n            }\n\n            // process ticker\n            // tickers are processed from a seperate websocket\n            if (subscription.tickers) {\n                const ticker = this._constructTicker(msg, market);\n                if (ticker.last && ticker.bid && ticker.ask) {\n                    this.emit(\"ticker\", ticker, market);\n                }\n                return;\n            }\n        }\n    }\n\n    protected _constructTrade(event, market, timestamp) {\n        const side = event.makerSide === \"ask\" ? \"sell\" : \"buy\";\n        const price = event.price;\n        const amount = event.amount;\n\n        return new Trade({\n            exchange: this.name,\n            base: market.base,\n            quote: market.quote,\n            tradeId: event.tid.toFixed(),\n            side,\n            unix: timestamp,\n            price,\n            amount,\n        });\n    }\n\n    protected _constructL2Snapshot(events, market, sequenceId, eventId) {\n        const asks = [];\n        const bids = [];\n\n        for (const { side, price, remaining, reason, delta } of events) {\n            const update = new Level2Point(price, remaining, undefined, { reason, delta });\n            if (side === \"ask\") asks.push(update);\n            else bids.push(update);\n        }\n\n        return new Level2Snapshot({\n            exchange: this.name,\n            base: market.base,\n            quote: market.quote,\n            sequenceId,\n            eventId,\n            asks,\n            bids,\n        });\n    }\n\n    protected _constructL2Update(events, market, sequenceId, timestampMs, eventId) {\n        const asks = [];\n        const bids = [];\n\n        for (const { side, price, remaining, reason, delta } of events) {\n            const update = new Level2Point(price, remaining, undefined, { reason, delta });\n            if (side === \"ask\") asks.push(update);\n            else bids.push(update);\n        }\n\n        return new Level2Update({\n            exchange: this.name,\n            base: market.base,\n            quote: market.quote,\n            sequenceId,\n            eventId,\n            timestampMs,\n            asks,\n            bids,\n        });\n    }\n\n    protected _constructTicker(msg, market): Ticker {\n        const ticker = this._getTicker(market);\n        for (let i = 0; i < msg.events.length; i++) {\n            const event = msg.events[i];\n\n            // asks - top_of_book in use\n            if (event.type === \"change\" && event.side === \"ask\") {\n                ticker.ask = event.price;\n                ticker.timestamp = msg.timestampms;\n            }\n\n            // bids - top_of_book in use\n            if (event.type === \"change\" && event.side === \"bid\") {\n                ticker.bid = event.price;\n                ticker.timestamp = msg.timestampms;\n            }\n\n            // attach latest trade information\n            if (event.type === \"trade\") {\n                ticker.last = event.price;\n                ticker.timestamp = msg.timestampms;\n            }\n        }\n\n        return ticker;\n    }\n\n    /**\n     * Ensures that a ticker for the market exists\n     * @param {*} market\n     */\n    protected _getTicker(market) {\n        if (!this.tickersCache.has(market.id)) {\n            this.tickersCache.set(\n                market.id,\n                new Ticker({\n                    exchange: this.name,\n                    base: market.base,\n                    quote: market.quote,\n                }),\n            );\n        }\n        return this.tickersCache.get(market.id);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}