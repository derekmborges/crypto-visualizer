{"ast":null,"code":"\"use strict\";\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CircularBuffer = void 0;\n/**\n * Implements a fast fixed size circular buffer. This buffer has O(1)\n * reads and write. The fixed size is limited to n-1 values in the\n * buffer. The final value is used as a marker to indicate that the\n * buffer is full. This trades a small amount of space for performance\n * by not requiring maintenance of a counter.\n *\n * In benchmarks this performs ~50,000 ops/sec which is twice as fast\n * as the `double-ended-queue` library.\n */\n\nclass CircularBuffer {\n  constructor(size) {\n    this.size = size;\n    this.buffer = new Array(size).fill(undefined);\n    this.writePos = 0;\n    this.readPos = 0;\n  }\n  /**\n   * Writes a value into the buffer. Returns `false` if the buffer is\n   * full. Otherwise returns `true`.\n   *\n   * @remarks\n   *\n   * The `writePos` is incremented prior to writing. This allows the\n   * `readPos` to chase the `writePos` and allows us to not require a\n   * counter that needs to be maintained.\n   */\n\n\n  write(val) {\n    const newPos = (this.writePos + 1) % this.size;\n    if (newPos === this.readPos) return false;\n    this.writePos = newPos;\n    this.buffer[this.writePos] = val;\n    return true;\n  }\n  /**\n   * Reads the next value from the circular buffer. Returns `undefined`\n   * when there is no data in the buffer.\n   *\n   * @remarks\n   *\n   * The `readPos` will chase the `writePos` and we increment the\n   * `readPos` prior to reading in the same way that we increment teh\n   * `writePos` prior to writing.\n   */\n\n\n  read() {\n    if (this.readPos === this.writePos) return; // empty\n\n    this.readPos = (this.readPos + 1) % this.size;\n    const val = this.buffer[this.readPos];\n    this.buffer[this.readPos] = undefined;\n    return val;\n  }\n\n}\n\nexports.CircularBuffer = CircularBuffer;","map":{"version":3,"sources":["/Users/Derek/workspace/crypto-visualizer/node_modules/ccxws/src/flowcontrol/CircularBuffer.ts"],"names":[],"mappings":";AAAA;;;;;;AAEA;;;;;;;;;AASG;;AACH,MAAa,cAAb,CAA2B;AAKvB,EAAA,WAAA,CAAqB,IAArB,EAAiC;AAAZ,SAAA,IAAA,GAAA,IAAA;AACjB,SAAK,MAAL,GAAc,IAAI,KAAJ,CAAU,IAAV,EAAgB,IAAhB,CAAqB,SAArB,CAAd;AACA,SAAK,QAAL,GAAgB,CAAhB;AACA,SAAK,OAAL,GAAe,CAAf;AACH;AAED;;;;;;;;;AASG;;;AACI,EAAA,KAAK,CAAC,GAAD,EAAO;AACf,UAAM,MAAM,GAAG,CAAC,KAAK,QAAL,GAAgB,CAAjB,IAAsB,KAAK,IAA1C;AACA,QAAI,MAAM,KAAK,KAAK,OAApB,EAA6B,OAAO,KAAP;AAC7B,SAAK,QAAL,GAAgB,MAAhB;AACA,SAAK,MAAL,CAAY,KAAK,QAAjB,IAA6B,GAA7B;AACA,WAAO,IAAP;AACH;AAED;;;;;;;;;AASG;;;AACI,EAAA,IAAI,GAAA;AACP,QAAI,KAAK,OAAL,KAAiB,KAAK,QAA1B,EAAoC,OAD7B,CACqC;;AAC5C,SAAK,OAAL,GAAe,CAAC,KAAK,OAAL,GAAe,CAAhB,IAAqB,KAAK,IAAzC;AACA,UAAM,GAAG,GAAG,KAAK,MAAL,CAAY,KAAK,OAAjB,CAAZ;AACA,SAAK,MAAL,CAAY,KAAK,OAAjB,IAA4B,SAA5B;AACA,WAAO,GAAP;AACH;;AA7CsB;;AAA3B,OAAA,CAAA,cAAA,GAAA,cAAA","sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\n/**\n * Implements a fast fixed size circular buffer. This buffer has O(1)\n * reads and write. The fixed size is limited to n-1 values in the\n * buffer. The final value is used as a marker to indicate that the\n * buffer is full. This trades a small amount of space for performance\n * by not requiring maintenance of a counter.\n *\n * In benchmarks this performs ~50,000 ops/sec which is twice as fast\n * as the `double-ended-queue` library.\n */\nexport class CircularBuffer<T> {\n    public buffer: T[];\n    public writePos: number;\n    public readPos: number;\n\n    constructor(readonly size: number) {\n        this.buffer = new Array(size).fill(undefined);\n        this.writePos = 0;\n        this.readPos = 0;\n    }\n\n    /**\n     * Writes a value into the buffer. Returns `false` if the buffer is\n     * full. Otherwise returns `true`.\n     *\n     * @remarks\n     *\n     * The `writePos` is incremented prior to writing. This allows the\n     * `readPos` to chase the `writePos` and allows us to not require a\n     * counter that needs to be maintained.\n     */\n    public write(val: T) {\n        const newPos = (this.writePos + 1) % this.size;\n        if (newPos === this.readPos) return false;\n        this.writePos = newPos;\n        this.buffer[this.writePos] = val;\n        return true;\n    }\n\n    /**\n     * Reads the next value from the circular buffer. Returns `undefined`\n     * when there is no data in the buffer.\n     *\n     * @remarks\n     *\n     * The `readPos` will chase the `writePos` and we increment the\n     * `readPos` prior to reading in the same way that we increment teh\n     * `writePos` prior to writing.\n     */\n    public read() {\n        if (this.readPos === this.writePos) return; // empty\n        this.readPos = (this.readPos + 1) % this.size;\n        const val = this.buffer[this.readPos];\n        this.buffer[this.readPos] = undefined;\n        return val;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}