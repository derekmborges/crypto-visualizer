{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inflateRaw = exports.inflate = exports.unzip = void 0;\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\nconst zlib_1 = __importDefault(require(\"zlib\"));\n\nconst Queue_1 = require(\"./flowcontrol/Queue\");\n\nconst queue = new Queue_1.Queue();\nlet current;\n/**\n * Serialized unzip using async zlib.unzip method. This function is a helper to\n * address issues with memory fragmentation issues as documented here:\n * https://nodejs.org/api/zlib.html#zlib_threadpool_usage_and_performance_considerations\n */\n\nfunction unzip(data, cb) {\n  queue.push([\"unzip\", data, cb]);\n  serialExecute();\n}\n\nexports.unzip = unzip;\n/**\n * Serialized inflate using async zlib.inflate method. This function is a helper to\n * address issues with memory fragmentation issues as documented here:\n * https://nodejs.org/api/zlib.html#zlib_threadpool_usage_and_performance_considerations\n */\n\nfunction inflate(data, cb) {\n  queue.push([\"inflate\", data, cb]);\n  serialExecute();\n}\n\nexports.inflate = inflate;\n/**\n * Serialized inflateRaw using async zlib.inflateRaw method. This function is a helper to\n * address issues with memory fragmentation issues as documented here:\n * https://nodejs.org/api/zlib.html#zlib_threadpool_usage_and_performance_considerations\n *\n */\n\nfunction inflateRaw(data, cb) {\n  queue.push([\"inflateRaw\", data, cb]);\n  serialExecute();\n}\n\nexports.inflateRaw = inflateRaw;\n\nfunction serialExecute() {\n  // abort if already executng\n  if (current) return; // remove first item and abort if nothing else to do\n\n  current = queue.shift();\n  if (!current) return; // perform unzip\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n\n  zlib_1.default[current[0]](current[1], (err, res) => {\n    // call supplied callback\n    current[2](err, res); // reset the current status\n\n    current = undefined; // immediate try next item\n\n    serialExecute();\n  });\n}","map":{"version":3,"sources":["/Users/Derek/workspace/crypto-visualizer/node_modules/ccxws/src/ZlibUtils.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AACA,MAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,MAAA,CAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AACA,MAAM,KAAK,GAAG,IAAI,OAAA,CAAA,KAAJ,EAAd;AAEA,IAAI,OAAJ;AAIA;;;;AAIG;;AACH,SAAgB,KAAhB,CAAsB,IAAtB,EAAoC,EAApC,EAAoD;AAChD,EAAA,KAAK,CAAC,IAAN,CAAW,CAAC,OAAD,EAAU,IAAV,EAAgB,EAAhB,CAAX;AACA,EAAA,aAAa;AAChB;;AAHD,OAAA,CAAA,KAAA,GAAA,KAAA;AAKA;;;;AAIG;;AACH,SAAgB,OAAhB,CAAwB,IAAxB,EAAsC,EAAtC,EAAsD;AAClD,EAAA,KAAK,CAAC,IAAN,CAAW,CAAC,SAAD,EAAY,IAAZ,EAAkB,EAAlB,CAAX;AACA,EAAA,aAAa;AAChB;;AAHD,OAAA,CAAA,OAAA,GAAA,OAAA;AAKA;;;;;AAKG;;AACH,SAAgB,UAAhB,CAA2B,IAA3B,EAAyC,EAAzC,EAAyD;AACrD,EAAA,KAAK,CAAC,IAAN,CAAW,CAAC,YAAD,EAAe,IAAf,EAAqB,EAArB,CAAX;AACA,EAAA,aAAa;AAChB;;AAHD,OAAA,CAAA,UAAA,GAAA,UAAA;;AAKA,SAAS,aAAT,GAAsB;AAClB;AACA,MAAI,OAAJ,EAAa,OAFK,CAIlB;;AACA,EAAA,OAAO,GAAG,KAAK,CAAC,KAAN,EAAV;AACA,MAAI,CAAC,OAAL,EAAc,OANI,CAQlB;AACA;;AACA,EAAA,MAAA,CAAA,OAAA,CAAK,OAAO,CAAC,CAAD,CAAZ,EAAiB,OAAO,CAAC,CAAD,CAAxB,EAA6B,CAAC,GAAD,EAAa,GAAb,KAA4B;AACrD;AACA,IAAA,OAAO,CAAC,CAAD,CAAP,CAAW,GAAX,EAAgB,GAAhB,EAFqD,CAIrD;;AACA,IAAA,OAAO,GAAG,SAAV,CALqD,CAOrD;;AACA,IAAA,aAAa;AAChB,GATD;AAUH","sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-assignment */\nimport zlib from \"zlib\";\nimport { Queue } from \"./flowcontrol/Queue\";\nconst queue = new Queue<any>();\n\nlet current: [string, Buffer, ZlibCallback];\n\nexport type ZlibCallback = (err: Error, result: Buffer) => void;\n\n/**\n * Serialized unzip using async zlib.unzip method. This function is a helper to\n * address issues with memory fragmentation issues as documented here:\n * https://nodejs.org/api/zlib.html#zlib_threadpool_usage_and_performance_considerations\n */\nexport function unzip(data: Buffer, cb: ZlibCallback): void {\n    queue.push([\"unzip\", data, cb]);\n    serialExecute();\n}\n\n/**\n * Serialized inflate using async zlib.inflate method. This function is a helper to\n * address issues with memory fragmentation issues as documented here:\n * https://nodejs.org/api/zlib.html#zlib_threadpool_usage_and_performance_considerations\n */\nexport function inflate(data: Buffer, cb: ZlibCallback): void {\n    queue.push([\"inflate\", data, cb]);\n    serialExecute();\n}\n\n/**\n * Serialized inflateRaw using async zlib.inflateRaw method. This function is a helper to\n * address issues with memory fragmentation issues as documented here:\n * https://nodejs.org/api/zlib.html#zlib_threadpool_usage_and_performance_considerations\n *\n */\nexport function inflateRaw(data: Buffer, cb: ZlibCallback) {\n    queue.push([\"inflateRaw\", data, cb]);\n    serialExecute();\n}\n\nfunction serialExecute() {\n    // abort if already executng\n    if (current) return;\n\n    // remove first item and abort if nothing else to do\n    current = queue.shift();\n    if (!current) return;\n\n    // perform unzip\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    zlib[current[0]](current[1], (err: Error, res: Buffer) => {\n        // call supplied callback\n        current[2](err, res);\n\n        // reset the current status\n        current = undefined;\n\n        // immediate try next item\n        serialExecute();\n    });\n}\n"]},"metadata":{},"sourceType":"script"}