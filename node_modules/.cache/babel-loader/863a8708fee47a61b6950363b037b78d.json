{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KrakenClient = void 0;\n/* eslint-disable @typescript-eslint/member-ordering */\n\n/* eslint-disable @typescript-eslint/restrict-plus-operands */\n\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n\n/* eslint-disable @typescript-eslint/no-unsafe-return */\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\nconst decimal_js_1 = __importDefault(require(\"decimal.js\"));\n\nconst BasicClient_1 = require(\"../BasicClient\");\n\nconst Candle_1 = require(\"../Candle\");\n\nconst CandlePeriod_1 = require(\"../CandlePeriod\");\n\nconst https = __importStar(require(\"../Https\"));\n\nconst Level2Point_1 = require(\"../Level2Point\");\n\nconst Level2Snapshots_1 = require(\"../Level2Snapshots\");\n\nconst Level2Update_1 = require(\"../Level2Update\");\n\nconst NotImplementedFn_1 = require(\"../NotImplementedFn\");\n\nconst Ticker_1 = require(\"../Ticker\");\n\nconst Trade_1 = require(\"../Trade\");\n/**\n    Kraken's API documentation is availble at:\n    https://www.kraken.com/features/websocket-api\n\n    Once the socket is open you can subscribe to a channel by sending\n    a subscribe request message.\n\n    Ping is initiated by the client, not the server. This means\n    we do not need to listen for pings events or respond appropriately.\n\n    Requests take an array of pairs to subscribe to an event. This means\n    when we subscribe or unsubscribe we need to send the COMPLETE list\n    of active markets. BasicClient maintains the list of active markets\n    in the various maps: _tickerSubs, _tradeSubs, _level2UpdateSubs.\n\n    This client will retrieve the market keys from those maps to\n    determine the remoteIds to send to the server on all sub/unsub requests.\n  */\n\n\nclass KrakenClient extends BasicClient_1.BasicClient {\n  constructor() {\n    let {\n      wssPath = \"wss://ws.kraken.com\",\n      autoloadSymbolMaps = true,\n      watcherMs\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(wssPath, \"Kraken\", undefined, watcherMs);\n    this._sendSubLevel2Snapshots = NotImplementedFn_1.NotImplementedFn;\n    this._sendUnsubLevel2Snapshots = NotImplementedFn_1.NotImplementedFn;\n    this._sendSubLevel3Snapshots = NotImplementedFn_1.NotImplementedFn;\n    this._sendUnsubLevel3Snapshots = NotImplementedFn_1.NotImplementedFn;\n    this._sendSubLevel3Updates = NotImplementedFn_1.NotImplementedFn;\n    this._sendUnsubLevel3Updates = NotImplementedFn_1.NotImplementedFn;\n    this.hasTickers = true;\n    this.hasTrades = true;\n    this.hasCandles = true;\n    this.hasLevel2Updates = true;\n    this.hasLevel2Snapshots = false;\n    this.candlePeriod = CandlePeriod_1.CandlePeriod._1m;\n    this.bookDepth = 500;\n    this.subscriptionLog = new Map();\n    this.debouceTimeoutHandles = new Map();\n    this.debounceWait = 200;\n    this.fromRestMap = new Map();\n    this.fromWsMap = new Map();\n\n    if (autoloadSymbolMaps) {\n      this.loadSymbolMaps().catch(err => this.emit(\"error\", err));\n    }\n  }\n  /**\n  Kraken made the websocket symbols different\n  than the REST symbols. Because CCXT uses the REST symbols,\n  we're going to default to receiving REST symbols and mapping them\n  to the corresponding WS symbol.\n   In order to do this, we'll need to retrieve the list of symbols from\n  the REST API. The constructor executes this.\n  */\n\n\n  async loadSymbolMaps() {\n    const uri = \"https://api.kraken.com/0/public/AssetPairs\";\n    const {\n      result\n    } = await https.get(uri);\n\n    for (const symbol in result) {\n      const restName = symbol;\n      const wsName = result[symbol].wsname;\n\n      if (wsName) {\n        this.fromRestMap.set(restName, wsName);\n        this.fromWsMap.set(wsName, restName);\n      }\n    }\n  }\n  /**\n  Helper that retrieves the list of ws symbols from the supplied\n  subscription map. The BasicClient manages the subscription maps\n  when subscribe<Trade|Ticker|etc> is called and adds the records.\n  This helper will take the values in a subscription map and\n  convert them into the websocket symbols, ensuring that markets\n  that are not mapped do not get included in the list.\n   @param map subscription map such as _tickerSubs or _tradeSubs\n  */\n\n\n  _wsSymbolsFromSubMap(map) {\n    const restSymbols = Array.from(map.keys());\n    return restSymbols.map(p => this.fromRestMap.get(p)).filter(p => p);\n  }\n  /**\n  Debounce is used to throttle a function that is repeatedly called. This\n  is applicable when many calls to subscribe or unsubscribe are executed\n  in quick succession by the calling application.\n  */\n\n\n  _debounce(type, fn) {\n    clearTimeout(this.debouceTimeoutHandles.get(type));\n    this.debouceTimeoutHandles.set(type, setTimeout(fn, this.debounceWait));\n  }\n  /**\n  This method is called by each of the _send* methods.  It uses\n  a debounce function on a given key so we can batch send the request\n  with the active symbols. We also need to convert the rest symbols\n  provided by the caller into websocket symbols used by the Kraken\n  ws server.\n   @param debounceKey unique key for the caller so each call\n  is debounced with related calls\n  @param subMap subscription map storing the current subs\n  for the type, such as _tickerSubs, _tradeSubs, etc.\n  @param subscribe true for subscribe, false for unsubscribe\n  @param subscription the subscription name passed to the\n  JSON-RPC call\n  */\n\n\n  _debounceSend(debounceKey, subMap, subscribe, subscription) {\n    this._debounce(debounceKey, () => {\n      const wsSymbols = this._wsSymbolsFromSubMap(subMap);\n\n      if (!this._wss) return;\n\n      this._wss.send(JSON.stringify({\n        event: subscribe ? \"subscribe\" : \"unsubscribe\",\n        pair: wsSymbols,\n        subscription\n      }));\n    });\n  }\n  /**\n  Constructs a request that looks like:\n  {\n    \"event\": \"subscribe\",\n    \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n    \"subscription\": {\n      \"name\": \"ticker\"\n    }\n  }\n  */\n\n\n  _sendSubTicker() {\n    this._debounceSend(\"sub-ticker\", this._tickerSubs, true, {\n      name: \"ticker\"\n    });\n  }\n  /**\n  Constructs a request that looks like:\n  {\n    \"event\": \"unsubscribe\",\n    \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n    \"subscription\": {\n      \"name\": \"ticker\"\n    }\n  }\n  */\n\n\n  _sendUnsubTicker() {\n    this._debounceSend(\"unsub-ticker\", this._tickerSubs, false, {\n      name: \"ticker\"\n    });\n  }\n  /**\n  Constructs a request that looks like:\n  {\n    \"event\": \"subscribe\",\n    \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n    \"subscription\": {\n      \"name\": \"trade\"\n    }\n  }\n  */\n\n\n  _sendSubTrades() {\n    this._debounceSend(\"sub-trades\", this._tradeSubs, true, {\n      name: \"trade\"\n    });\n  }\n  /**\n  Constructs a request that looks like:\n  {\n    \"event\": \"unsubscribe\",\n    \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n    \"subscription\": {\n      \"name\": \"trade\"\n    }\n  }\n  */\n\n\n  _sendUnsubTrades() {\n    this._debounceSend(\"unsub-trades\", this._tradeSubs, false, {\n      name: \"trade\"\n    });\n  }\n  /**\n  * Constructs a request that looks like:\n  {\n    \"event\": \"unsubscribe\",\n    \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n    \"subscription\": {\n      \"name\": \"ohlc\"\n      \"interval\": 1\n    }\n  }\n  */\n\n\n  _sendSubCandles() {\n    const interval = getCandlePeriod(this.candlePeriod);\n\n    this._debounceSend(\"sub-candles\", this._candleSubs, true, {\n      name: \"ohlc\",\n      interval\n    });\n  }\n  /**\n  * Constructs a request that looks like:\n  {\n    \"event\": \"unsubscribe\",\n    \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n    \"subscription\": {\n      \"name\": \"ohlc\"\n      \"interval\": 1\n    }\n  }\n  */\n\n\n  _sendUnsubCandles() {\n    const interval = getCandlePeriod(this.candlePeriod);\n\n    this._debounceSend(\"unsub-candles\", this._candleSubs, false, {\n      name: \"ohlc\",\n      interval\n    });\n  }\n  /**\n  Constructs a request that looks like:\n  {\n    \"event\": \"subscribe\",\n    \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n    \"subscription\": {\n      \"name\": \"book\"\n    }\n  }\n  */\n\n\n  _sendSubLevel2Updates() {\n    this._debounceSend(\"sub-l2updates\", this._level2UpdateSubs, true, {\n      name: \"book\",\n      depth: this.bookDepth\n    });\n  }\n  /**\n  Constructs a request that looks like:\n  {\n    \"event\": \"unsubscribe\",\n    \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n    \"subscription\": {\n      \"name\": \"trade\"\n    }\n  }\n  */\n\n\n  _sendUnsubLevel2Updates() {\n    this._debounceSend(\"unsub-l2updates\", this._level2UpdateSubs, false, {\n      name: \"book\"\n    });\n  }\n  /**\n  Handle for incoming messages\n  @param raw\n  */\n\n\n  _onMessage(raw) {\n    const msgs = JSON.parse(raw);\n\n    this._processsMessage(msgs);\n  }\n  /**\n  When a subscription is initiated, a subscriptionStatus event is sent.\n  This message will be cached in the subscriptionLog for look up later.\n  When messages arrive, they only contain the subscription id.  The\n  id is used to look up the subscription details in the subscriptionLog\n  to determine what the message means.\n  */\n\n\n  _processsMessage(msg) {\n    if (msg.event === \"heartbeat\") {\n      return;\n    }\n\n    if (msg.event === \"systemStatus\") {\n      return;\n    } // Capture the subscription metadata for use later.\n\n\n    if (msg.event === \"subscriptionStatus\") {\n      /*\n          {\n          channelID: '15',\n          event: 'subscriptionStatus',\n          pair: 'XBT/EUR',\n          status: 'subscribed',\n          subscription: { name: 'ticker' }\n          }\n      */\n      this.subscriptionLog.set(parseInt(msg.channelID), msg);\n      return;\n    } // All messages from this point forward should arrive as an array\n\n\n    if (!Array.isArray(msg)) {\n      return;\n    }\n\n    const [subscriptionId, details] = msg;\n    const sl = this.subscriptionLog.get(subscriptionId); // If we don't have a subscription log entry for this event then\n    // we need to abort since we don't know what to do with it!\n    // From the subscriptionLog entry's pair, we can convert\n    // the ws symbol into a rest symbol\n\n    const remote_id = this.fromWsMap.get(sl.pair); // tickers\n\n    if (sl.subscription.name === \"ticker\") {\n      const market = this._tickerSubs.get(remote_id);\n\n      if (!market) return;\n\n      const ticker = this._constructTicker(details, market);\n\n      if (ticker) {\n        this.emit(\"ticker\", ticker, market);\n      }\n\n      return;\n    } // trades\n\n\n    if (sl.subscription.name === \"trade\") {\n      if (Array.isArray(msg[1])) {\n        const market = this._tradeSubs.get(remote_id);\n\n        if (!market) return;\n\n        for (const t of msg[1]) {\n          const trade = this._constructTrade(t, market);\n\n          if (trade) {\n            this.emit(\"trade\", trade, market);\n          }\n        }\n      }\n\n      return;\n    } // candles\n\n\n    if (sl.subscription.name === \"ohlc\") {\n      const market = this._candleSubs.get(remote_id);\n\n      if (!market) return;\n\n      const candle = this._constructCandle(msg);\n\n      this.emit(\"candle\", candle, market);\n      return;\n    } //l2 updates\n\n\n    if (sl.subscription.name === \"book\") {\n      const market = this._level2UpdateSubs.get(remote_id);\n\n      if (!market) return; // snapshot use as/bs\n      // updates us a/b\n\n      const isSnapshot = !!msg[1].as;\n\n      if (isSnapshot) {\n        const l2snapshot = this._constructLevel2Snapshot(msg[1], market);\n\n        if (l2snapshot) {\n          this.emit(\"l2snapshot\", l2snapshot, market, msg);\n        }\n      } else {\n        const l2update = this._constructLevel2Update(msg, market);\n\n        if (l2update) {\n          this.emit(\"l2update\", l2update, market, msg);\n        }\n      }\n    }\n\n    return;\n  }\n  /**\n  Refer to https://www.kraken.com/en-us/features/websocket-api#message-ticker\n  */\n\n\n  _constructTicker(msg, market) {\n    /*\n    { a: [ '3343.70000', 1, '1.03031692' ],\n    b: [ '3342.20000', 1, '1.00000000' ],\n    c: [ '3343.70000', '0.01000000' ],\n    v: [ '4514.26000539', '7033.48119179' ],\n    p: [ '3357.13865', '3336.28299' ],\n    t: [ 14731, 22693 ],\n    l: [ '3308.40000', '3223.90000' ],\n    h: [ '3420.00000', '3420.00000' ],\n    o: [ '3339.40000', '3349.00000' ] }\n    */\n    // calculate change and change percent based from the open/close\n    // prices\n    const open = parseFloat(msg.o[1]);\n    const last = parseFloat(msg.c[0]);\n    const change = open - last;\n    const changePercent = (last - open) / open * 100; // calculate the quoteVolume by multiplying the volume\n    // over the last 24h by the 24h vwap\n\n    const quoteVolume = parseFloat(msg.v[1]) * parseFloat(msg.p[1]);\n    return new Ticker_1.Ticker({\n      exchange: this.name,\n      base: market.base,\n      quote: market.quote,\n      timestamp: Date.now(),\n      last: msg.c[0],\n      open: msg.o[1],\n      high: msg.h[0],\n      low: msg.l[0],\n      volume: msg.v[1],\n      quoteVolume: quoteVolume.toFixed(8),\n      change: change.toFixed(8),\n      changePercent: changePercent.toFixed(2),\n      bid: msg.b[0],\n      bidVolume: msg.b[2],\n      ask: msg.a[0],\n      askVolume: msg.a[2]\n    });\n  }\n  /**\n  Refer to https://www.kraken.com/en-us/features/websocket-api#message-trade\n   Since Kraken doesn't send a trade Id we create a surrogate from\n  the time stamp. This can result in duplicate trade Ids being generated.\n  Additionaly mechanism will need to be put into place by the consumer to\n  dedupe them.\n  */\n\n\n  _constructTrade(datum, market) {\n    /*\n    [ '3363.20000', '0.05168143', '1551432237.079148', 'b', 'l', '' ]\n    */\n    const side = datum[3] === \"b\" ? \"buy\" : \"sell\"; // see above\n\n    const tradeId = this._createTradeId(datum[2]); // convert to ms timestamp as an int\n\n\n    const unix = parseInt(parseFloat(datum[2]) * 1000);\n    return new Trade_1.Trade({\n      exchange: this.name,\n      base: market.base,\n      quote: market.quote,\n      tradeId,\n      side: side,\n      unix,\n      price: datum[0],\n      amount: datum[1],\n      rawUnix: datum[2]\n    });\n  }\n  /**\n  Refer to https://www.kraken.com/en-us/features/websocket-api#message-ohlc\n  */\n\n\n  _constructCandle(msg) {\n    /**\n    [\n    6,\n    [ '1571080988.157759',\n      '1571081040.000000',\n      '8352.00000',\n      '8352.00000',\n      '8352.00000',\n      '8352.00000',\n      '8352.00000',\n      '0.01322211',\n      1\n    ],\n    'ohlc-1',\n    'XBT/USD'\n    ]\n    */\n    const datum = msg[1];\n    const ms = parseInt(datum[1]) * 1000;\n    return new Candle_1.Candle(ms, datum[2], datum[3], datum[4], datum[5], datum[7]);\n  }\n  /**\n   * Refer to https://www.kraken.com/en-us/features/websocket-api#message-book\n   * Values will look like:\n   * [\n   *    270,\n   *    {\"b\":[[\"11260.50000\",\"0.00000000\",\"1596221402.104952\"],[\"11228.70000\",\"2.60111463\",\"1596221103.546084\",\"r\"]],\"c\":\"1281654047\"},\n   *    \"book-100\",\n   *    \"XBT/USD\"\n   * ]\n   *\n   * [\n   *    270,\n   *    {\"a\":[[\"11277.30000\",\"1.01949833\",\"1596221402.163693\"]]},\n   *    {\"b\":[[\"11275.30000\",\"0.17300000\",\"1596221402.163680\"]],\"c\":\"1036980588\"},\n   *    \"book-100\",\n   *    \"XBT/USD\"\n   * ]\n   */\n\n\n  _constructLevel2Update(msg, market) {\n    const asks = [];\n    const bids = [];\n    let checksum; // Because some messages will send more than a single result object\n    // we need to iterate the results blocks starting at position 1 and\n    // look for ask, bid, and checksum data.\n\n    for (let i = 1; i < msg.length; i++) {\n      // Process ask updates\n      if (msg[i].a) {\n        for (const [price, size, timestamp] of msg[i].a) {\n          asks.push(new Level2Point_1.Level2Point(price, size, undefined, undefined, timestamp));\n        }\n      } // Process bid updates\n\n\n      if (msg[i].b) {\n        for (const [price, size, timestamp] of msg[i].b) {\n          bids.push(new Level2Point_1.Level2Point(price, size, undefined, undefined, timestamp));\n        }\n      } // Process checksum\n\n\n      if (msg[i].c) {\n        checksum = msg[i].c;\n      }\n    } // Calculates the newest timestamp value to maintain backwards\n    // compatibility with the update timestamp\n\n\n    const timestamp = Math.max(...asks.concat(bids).map(p => parseFloat(p.timestamp)));\n    return new Level2Update_1.Level2Update({\n      exchange: this.name,\n      base: market.base,\n      quote: market.quote,\n      timestampMs: parseInt(timestamp * 1000),\n      asks,\n      bids,\n      checksum\n    });\n  }\n  /**\n   * Refer to https://www.kraken.com/en-us/features/websocket-api#message-book\n   *\n   *   {\n   *     as: [\n   *       [ '3361.30000', '25.57512297', '1551438550.367822' ],\n   *       [ '3363.80000', '15.81228000', '1551438539.149525' ]\n   *     ],\n   *     bs: [\n   *       [ '3361.20000', '0.07234101', '1551438547.041624' ],\n   *       [ '3357.60000', '1.75000000', '1551438516.825218' ]\n   *     ]\n   *   }\n   */\n\n\n  _constructLevel2Snapshot(datum, market) {\n    // Process asks\n    const as = datum.as || [];\n    const asks = [];\n\n    for (const [price, size, timestamp] of as) {\n      asks.push(new Level2Point_1.Level2Point(price, size, undefined, undefined, timestamp));\n    } // Process bids\n\n\n    const bs = datum.bs || [];\n    const bids = [];\n\n    for (const [price, size, timestamp] of bs) {\n      bids.push(new Level2Point_1.Level2Point(price, size, undefined, undefined, timestamp));\n    } // Calculates the newest timestamp value to maintain backwards\n    // compatibility with the update timestamp\n\n\n    const timestamp = Math.max(...asks.concat(bids).map(p => parseFloat(p.timestamp)));\n    return new Level2Snapshots_1.Level2Snapshot({\n      exchange: this.name,\n      base: market.base,\n      quote: market.quote,\n      timestampMs: parseInt(timestamp * 1000),\n      asks,\n      bids\n    });\n  }\n  /**\n  Since Kraken doesn't send a trade id, we need to come up with a way\n  to generate one on our own. The REST API include the last trade id\n  which gives us the clue that it is the second timestamp + 9 sub-second\n  digits.\n   The WS will provide timestamps with up to 6 decimals of precision.\n  The REST API only has timestamps with 4 decimal of precision.\n   To maintain consistency, we're going to use the following formula:\n    <integer part of unix timestamp> +\n    <first 4 digits of fractional part of unix timestamp> +\n    00000\n    We're using the ROUND_HALF_UP method. From testing, this resulted\n  in the best rounding results. Ids are in picoseconds, the websocket\n  is broadcast in microsecond, and the REST results are truncated to\n  4 decimals.\n   This mean it is impossible to determine the rounding algorithm or\n  the proper rounding to go from 6 to 4 decimals as the 6 decimals\n  are being rounded from 9 which causes issues as the half\n  point for 4 digit rounding\n    .222950 rounds up to .2230 if the pico_ms value is > .222295000\n    .222950 rounds down to .2229 if the pico_ms value is < .222295000\n   Consumer code will need to account for collisions and id mismatch.\n  */\n\n\n  _createTradeId(unix) {\n    const roundMode = decimal_js_1.default.ROUND_HALF_UP;\n    const [integer, frac] = unix.split(\".\");\n    const fracResult = new decimal_js_1.default(\"0.\" + frac).toDecimalPlaces(4, roundMode).toFixed(4).split(\".\")[1];\n    return integer + fracResult + \"00000\";\n  }\n\n}\n\nexports.KrakenClient = KrakenClient;\n/**\n * Maps the candle period from CCXWS to those required by the subscription mechanism\n * as defined in https://www.kraken.com/en-us/features/websocket-api#message-subscribe\n * @paramp\n */\n\nfunction getCandlePeriod(p) {\n  switch (p) {\n    case CandlePeriod_1.CandlePeriod._1m:\n      return 1;\n\n    case CandlePeriod_1.CandlePeriod._5m:\n      return 5;\n\n    case CandlePeriod_1.CandlePeriod._15m:\n      return 15;\n\n    case CandlePeriod_1.CandlePeriod._30m:\n      return 30;\n\n    case CandlePeriod_1.CandlePeriod._1h:\n      return 60;\n\n    case CandlePeriod_1.CandlePeriod._4h:\n      return 240;\n\n    case CandlePeriod_1.CandlePeriod._1d:\n      return 1440;\n\n    case CandlePeriod_1.CandlePeriod._1w:\n      return 10080;\n\n    case CandlePeriod_1.CandlePeriod._2w:\n      return 21600;\n  }\n}","map":{"version":3,"sources":["/Users/Derek/workspace/crypto-visualizer/node_modules/ccxws/src/exchanges/KrakenClient.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/member-ordering */\n/* eslint-disable @typescript-eslint/restrict-plus-operands */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-return */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\nimport Decimal from \"decimal.js\";\nimport { BasicClient, MarketMap } from \"../BasicClient\";\nimport { Candle } from \"../Candle\";\nimport { CandlePeriod } from \"../CandlePeriod\";\nimport { ClientOptions } from \"../ClientOptions\";\nimport * as https from \"../Https\";\nimport { Level2Point } from \"../Level2Point\";\nimport { Level2Snapshot } from \"../Level2Snapshots\";\nimport { Level2Update } from \"../Level2Update\";\nimport { NotImplementedFn } from \"../NotImplementedFn\";\nimport { Ticker } from \"../Ticker\";\nimport { Trade } from \"../Trade\";\n\nexport type KrakenClientOptions = ClientOptions & { autoloadSymbolMaps?: boolean };\n\n/**\n    Kraken's API documentation is availble at:\n    https://www.kraken.com/features/websocket-api\n\n    Once the socket is open you can subscribe to a channel by sending\n    a subscribe request message.\n\n    Ping is initiated by the client, not the server. This means\n    we do not need to listen for pings events or respond appropriately.\n\n    Requests take an array of pairs to subscribe to an event. This means\n    when we subscribe or unsubscribe we need to send the COMPLETE list\n    of active markets. BasicClient maintains the list of active markets\n    in the various maps: _tickerSubs, _tradeSubs, _level2UpdateSubs.\n\n    This client will retrieve the market keys from those maps to\n    determine the remoteIds to send to the server on all sub/unsub requests.\n  */\nexport class KrakenClient extends BasicClient {\n    public candlePeriod: CandlePeriod;\n    public bookDepth: number;\n    public debounceWait: number;\n\n    protected debouceTimeoutHandles: Map<string, NodeJS.Timeout>;\n    protected subscriptionLog: Map<number, any>;\n    protected fromRestMap: Map<string, string>;\n    protected fromWsMap: Map<string, string>;\n\n    constructor({\n        wssPath = \"wss://ws.kraken.com\",\n        autoloadSymbolMaps = true,\n        watcherMs,\n    }: KrakenClientOptions = {}) {\n        super(wssPath, \"Kraken\", undefined, watcherMs);\n\n        this.hasTickers = true;\n        this.hasTrades = true;\n        this.hasCandles = true;\n        this.hasLevel2Updates = true;\n        this.hasLevel2Snapshots = false;\n\n        this.candlePeriod = CandlePeriod._1m;\n        this.bookDepth = 500;\n\n        this.subscriptionLog = new Map();\n        this.debouceTimeoutHandles = new Map();\n        this.debounceWait = 200;\n\n        this.fromRestMap = new Map();\n        this.fromWsMap = new Map();\n\n        if (autoloadSymbolMaps) {\n            this.loadSymbolMaps().catch(err => this.emit(\"error\", err));\n        }\n    }\n\n    /**\n    Kraken made the websocket symbols different\n    than the REST symbols. Because CCXT uses the REST symbols,\n    we're going to default to receiving REST symbols and mapping them\n    to the corresponding WS symbol.\n\n    In order to do this, we'll need to retrieve the list of symbols from\n    the REST API. The constructor executes this.\n   */\n    public async loadSymbolMaps() {\n        const uri = \"https://api.kraken.com/0/public/AssetPairs\";\n        const { result } = await https.get(uri);\n        for (const symbol in result) {\n            const restName = symbol;\n            const wsName = result[symbol].wsname;\n            if (wsName) {\n                this.fromRestMap.set(restName, wsName);\n                this.fromWsMap.set(wsName, restName);\n            }\n        }\n    }\n\n    /**\n    Helper that retrieves the list of ws symbols from the supplied\n    subscription map. The BasicClient manages the subscription maps\n    when subscribe<Trade|Ticker|etc> is called and adds the records.\n    This helper will take the values in a subscription map and\n    convert them into the websocket symbols, ensuring that markets\n    that are not mapped do not get included in the list.\n\n    @param map subscription map such as _tickerSubs or _tradeSubs\n   */\n    protected _wsSymbolsFromSubMap(map: MarketMap) {\n        const restSymbols = Array.from(map.keys());\n        return restSymbols.map(p => this.fromRestMap.get(p)).filter(p => p);\n    }\n\n    /**\n    Debounce is used to throttle a function that is repeatedly called. This\n    is applicable when many calls to subscribe or unsubscribe are executed\n    in quick succession by the calling application.\n   */\n    protected _debounce(type: string, fn: () => void) {\n        clearTimeout(this.debouceTimeoutHandles.get(type));\n        this.debouceTimeoutHandles.set(type, setTimeout(fn, this.debounceWait));\n    }\n\n    /**\n    This method is called by each of the _send* methods.  It uses\n    a debounce function on a given key so we can batch send the request\n    with the active symbols. We also need to convert the rest symbols\n    provided by the caller into websocket symbols used by the Kraken\n    ws server.\n\n    @param debounceKey unique key for the caller so each call\n    is debounced with related calls\n    @param subMap subscription map storing the current subs\n    for the type, such as _tickerSubs, _tradeSubs, etc.\n    @param subscribe true for subscribe, false for unsubscribe\n    @param subscription the subscription name passed to the\n    JSON-RPC call\n   */\n    protected _debounceSend(\n        debounceKey: string,\n        subMap: MarketMap,\n        subscribe: boolean,\n        subscription: { name: string; [x: string]: any },\n    ) {\n        this._debounce(debounceKey, () => {\n            const wsSymbols = this._wsSymbolsFromSubMap(subMap);\n            if (!this._wss) return;\n            this._wss.send(\n                JSON.stringify({\n                    event: subscribe ? \"subscribe\" : \"unsubscribe\",\n                    pair: wsSymbols,\n                    subscription,\n                }),\n            );\n        });\n    }\n\n    /**\n    Constructs a request that looks like:\n    {\n      \"event\": \"subscribe\",\n      \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n      \"subscription\": {\n        \"name\": \"ticker\"\n      }\n    }\n   */\n    protected _sendSubTicker() {\n        this._debounceSend(\"sub-ticker\", this._tickerSubs, true, { name: \"ticker\" });\n    }\n\n    /**\n    Constructs a request that looks like:\n    {\n      \"event\": \"unsubscribe\",\n      \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n      \"subscription\": {\n        \"name\": \"ticker\"\n      }\n    }\n   */\n    protected _sendUnsubTicker() {\n        this._debounceSend(\"unsub-ticker\", this._tickerSubs, false, { name: \"ticker\" });\n    }\n\n    /**\n    Constructs a request that looks like:\n    {\n      \"event\": \"subscribe\",\n      \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n      \"subscription\": {\n        \"name\": \"trade\"\n      }\n    }\n   */\n    protected _sendSubTrades() {\n        this._debounceSend(\"sub-trades\", this._tradeSubs, true, { name: \"trade\" });\n    }\n\n    /**\n    Constructs a request that looks like:\n    {\n      \"event\": \"unsubscribe\",\n      \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n      \"subscription\": {\n        \"name\": \"trade\"\n      }\n    }\n   */\n    protected _sendUnsubTrades() {\n        this._debounceSend(\"unsub-trades\", this._tradeSubs, false, { name: \"trade\" });\n    }\n\n    /**\n   * Constructs a request that looks like:\n    {\n      \"event\": \"unsubscribe\",\n      \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n      \"subscription\": {\n        \"name\": \"ohlc\"\n        \"interval\": 1\n      }\n    }\n   */\n    protected _sendSubCandles() {\n        const interval = getCandlePeriod(this.candlePeriod);\n        this._debounceSend(\"sub-candles\", this._candleSubs, true, { name: \"ohlc\", interval });\n    }\n\n    /**\n   * Constructs a request that looks like:\n    {\n      \"event\": \"unsubscribe\",\n      \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n      \"subscription\": {\n        \"name\": \"ohlc\"\n        \"interval\": 1\n      }\n    }\n   */\n    protected _sendUnsubCandles() {\n        const interval = getCandlePeriod(this.candlePeriod);\n        this._debounceSend(\"unsub-candles\", this._candleSubs, false, { name: \"ohlc\", interval });\n    }\n\n    /**\n    Constructs a request that looks like:\n    {\n      \"event\": \"subscribe\",\n      \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n      \"subscription\": {\n        \"name\": \"book\"\n      }\n    }\n   */\n    protected _sendSubLevel2Updates() {\n        this._debounceSend(\"sub-l2updates\", this._level2UpdateSubs, true, {\n            name: \"book\",\n            depth: this.bookDepth,\n        });\n    }\n\n    /**\n    Constructs a request that looks like:\n    {\n      \"event\": \"unsubscribe\",\n      \"pair\": [\"XBT/USD\",\"BCH/USD\"]\n      \"subscription\": {\n        \"name\": \"trade\"\n      }\n    }\n   */\n    protected _sendUnsubLevel2Updates() {\n        this._debounceSend(\"unsub-l2updates\", this._level2UpdateSubs, false, { name: \"book\" });\n    }\n\n    /**\n    Handle for incoming messages\n    @param raw\n   */\n    protected _onMessage(raw: string) {\n        const msgs = JSON.parse(raw);\n        this._processsMessage(msgs);\n    }\n\n    protected _sendSubLevel2Snapshots = NotImplementedFn;\n    protected _sendUnsubLevel2Snapshots = NotImplementedFn;\n    protected _sendSubLevel3Snapshots = NotImplementedFn;\n    protected _sendUnsubLevel3Snapshots = NotImplementedFn;\n    protected _sendSubLevel3Updates = NotImplementedFn;\n    protected _sendUnsubLevel3Updates = NotImplementedFn;\n\n    /**\n    When a subscription is initiated, a subscriptionStatus event is sent.\n    This message will be cached in the subscriptionLog for look up later.\n    When messages arrive, they only contain the subscription id.  The\n    id is used to look up the subscription details in the subscriptionLog\n    to determine what the message means.\n   */\n    protected _processsMessage(msg: any) {\n        if (msg.event === \"heartbeat\") {\n            return;\n        }\n\n        if (msg.event === \"systemStatus\") {\n            return;\n        }\n\n        // Capture the subscription metadata for use later.\n        if (msg.event === \"subscriptionStatus\") {\n            /*\n                {\n                channelID: '15',\n                event: 'subscriptionStatus',\n                pair: 'XBT/EUR',\n                status: 'subscribed',\n                subscription: { name: 'ticker' }\n                }\n            */\n            this.subscriptionLog.set(parseInt(msg.channelID), msg);\n            return;\n        }\n\n        // All messages from this point forward should arrive as an array\n        if (!Array.isArray(msg)) {\n            return;\n        }\n\n        const [subscriptionId, details] = msg;\n        const sl = this.subscriptionLog.get(subscriptionId);\n\n        // If we don't have a subscription log entry for this event then\n        // we need to abort since we don't know what to do with it!\n\n        // From the subscriptionLog entry's pair, we can convert\n        // the ws symbol into a rest symbol\n        const remote_id = this.fromWsMap.get(sl.pair);\n\n        // tickers\n        if (sl.subscription.name === \"ticker\") {\n            const market = this._tickerSubs.get(remote_id);\n            if (!market) return;\n\n            const ticker = this._constructTicker(details, market);\n            if (ticker) {\n                this.emit(\"ticker\", ticker, market);\n            }\n            return;\n        }\n\n        // trades\n        if (sl.subscription.name === \"trade\") {\n            if (Array.isArray(msg[1])) {\n                const market = this._tradeSubs.get(remote_id);\n                if (!market) return;\n\n                for (const t of msg[1]) {\n                    const trade = this._constructTrade(t, market);\n                    if (trade) {\n                        this.emit(\"trade\", trade, market);\n                    }\n                }\n            }\n            return;\n        }\n\n        // candles\n        if (sl.subscription.name === \"ohlc\") {\n            const market = this._candleSubs.get(remote_id);\n            if (!market) return;\n\n            const candle = this._constructCandle(msg);\n            this.emit(\"candle\", candle, market);\n            return;\n        }\n\n        //l2 updates\n        if (sl.subscription.name === \"book\") {\n            const market = this._level2UpdateSubs.get(remote_id);\n            if (!market) return;\n\n            // snapshot use as/bs\n            // updates us a/b\n            const isSnapshot = !!msg[1].as;\n            if (isSnapshot) {\n                const l2snapshot = this._constructLevel2Snapshot(msg[1], market);\n                if (l2snapshot) {\n                    this.emit(\"l2snapshot\", l2snapshot, market, msg);\n                }\n            } else {\n                const l2update = this._constructLevel2Update(msg, market);\n                if (l2update) {\n                    this.emit(\"l2update\", l2update, market, msg);\n                }\n            }\n        }\n        return;\n    }\n\n    /**\n    Refer to https://www.kraken.com/en-us/features/websocket-api#message-ticker\n   */\n    protected _constructTicker(msg, market) {\n        /*\n      { a: [ '3343.70000', 1, '1.03031692' ],\n        b: [ '3342.20000', 1, '1.00000000' ],\n        c: [ '3343.70000', '0.01000000' ],\n        v: [ '4514.26000539', '7033.48119179' ],\n        p: [ '3357.13865', '3336.28299' ],\n        t: [ 14731, 22693 ],\n        l: [ '3308.40000', '3223.90000' ],\n        h: [ '3420.00000', '3420.00000' ],\n        o: [ '3339.40000', '3349.00000' ] }\n    */\n\n        // calculate change and change percent based from the open/close\n        // prices\n        const open = parseFloat(msg.o[1]);\n        const last = parseFloat(msg.c[0]);\n        const change = open - last;\n        const changePercent = ((last - open) / open) * 100;\n\n        // calculate the quoteVolume by multiplying the volume\n        // over the last 24h by the 24h vwap\n        const quoteVolume = parseFloat(msg.v[1]) * parseFloat(msg.p[1]);\n\n        return new Ticker({\n            exchange: this.name,\n            base: market.base,\n            quote: market.quote,\n            timestamp: Date.now(),\n            last: msg.c[0],\n            open: msg.o[1],\n            high: msg.h[0],\n            low: msg.l[0],\n            volume: msg.v[1],\n            quoteVolume: quoteVolume.toFixed(8),\n            change: change.toFixed(8),\n            changePercent: changePercent.toFixed(2),\n            bid: msg.b[0],\n            bidVolume: msg.b[2],\n            ask: msg.a[0],\n            askVolume: msg.a[2],\n        });\n    }\n\n    /**\n    Refer to https://www.kraken.com/en-us/features/websocket-api#message-trade\n\n    Since Kraken doesn't send a trade Id we create a surrogate from\n    the time stamp. This can result in duplicate trade Ids being generated.\n    Additionaly mechanism will need to be put into place by the consumer to\n    dedupe them.\n   */\n    protected _constructTrade(datum, market) {\n        /*\n    [ '3363.20000', '0.05168143', '1551432237.079148', 'b', 'l', '' ]\n    */\n        const side = datum[3] === \"b\" ? \"buy\" : \"sell\";\n\n        // see above\n        const tradeId = this._createTradeId(datum[2]);\n\n        // convert to ms timestamp as an int\n        const unix = parseInt((parseFloat(datum[2]) * 1000) as any);\n\n        return new Trade({\n            exchange: this.name,\n            base: market.base,\n            quote: market.quote,\n            tradeId,\n            side: side,\n            unix,\n            price: datum[0],\n            amount: datum[1],\n            rawUnix: datum[2],\n        });\n    }\n\n    /**\n    Refer to https://www.kraken.com/en-us/features/websocket-api#message-ohlc\n   */\n    protected _constructCandle(msg) {\n        /**\n      [\n        6,\n        [ '1571080988.157759',\n          '1571081040.000000',\n          '8352.00000',\n          '8352.00000',\n          '8352.00000',\n          '8352.00000',\n          '8352.00000',\n          '0.01322211',\n          1\n        ],\n        'ohlc-1',\n        'XBT/USD'\n      ]\n      */\n        const datum = msg[1];\n        const ms = parseInt(datum[1]) * 1000;\n        return new Candle(ms, datum[2], datum[3], datum[4], datum[5], datum[7]);\n    }\n\n    /**\n     * Refer to https://www.kraken.com/en-us/features/websocket-api#message-book\n     * Values will look like:\n     * [\n     *    270,\n     *    {\"b\":[[\"11260.50000\",\"0.00000000\",\"1596221402.104952\"],[\"11228.70000\",\"2.60111463\",\"1596221103.546084\",\"r\"]],\"c\":\"1281654047\"},\n     *    \"book-100\",\n     *    \"XBT/USD\"\n     * ]\n     *\n     * [\n     *    270,\n     *    {\"a\":[[\"11277.30000\",\"1.01949833\",\"1596221402.163693\"]]},\n     *    {\"b\":[[\"11275.30000\",\"0.17300000\",\"1596221402.163680\"]],\"c\":\"1036980588\"},\n     *    \"book-100\",\n     *    \"XBT/USD\"\n     * ]\n     */\n    protected _constructLevel2Update(msg, market) {\n        const asks = [];\n        const bids = [];\n        let checksum;\n\n        // Because some messages will send more than a single result object\n        // we need to iterate the results blocks starting at position 1 and\n        // look for ask, bid, and checksum data.\n        for (let i = 1; i < msg.length; i++) {\n            // Process ask updates\n            if (msg[i].a) {\n                for (const [price, size, timestamp] of msg[i].a) {\n                    asks.push(new Level2Point(price, size, undefined, undefined, timestamp));\n                }\n            }\n\n            // Process bid updates\n            if (msg[i].b) {\n                for (const [price, size, timestamp] of msg[i].b) {\n                    bids.push(new Level2Point(price, size, undefined, undefined, timestamp));\n                }\n            }\n\n            // Process checksum\n            if (msg[i].c) {\n                checksum = msg[i].c;\n            }\n        }\n\n        // Calculates the newest timestamp value to maintain backwards\n        // compatibility with the update timestamp\n        const timestamp = Math.max(...asks.concat(bids).map(p => parseFloat(p.timestamp)));\n\n        return new Level2Update({\n            exchange: this.name,\n            base: market.base,\n            quote: market.quote,\n            timestampMs: parseInt((timestamp * 1000) as any),\n            asks,\n            bids,\n            checksum,\n        });\n    }\n\n    /**\n     * Refer to https://www.kraken.com/en-us/features/websocket-api#message-book\n     *\n     *   {\n     *     as: [\n     *       [ '3361.30000', '25.57512297', '1551438550.367822' ],\n     *       [ '3363.80000', '15.81228000', '1551438539.149525' ]\n     *     ],\n     *     bs: [\n     *       [ '3361.20000', '0.07234101', '1551438547.041624' ],\n     *       [ '3357.60000', '1.75000000', '1551438516.825218' ]\n     *     ]\n     *   }\n     */\n    protected _constructLevel2Snapshot(datum, market) {\n        // Process asks\n        const as = datum.as || [];\n        const asks = [];\n        for (const [price, size, timestamp] of as) {\n            asks.push(new Level2Point(price, size, undefined, undefined, timestamp));\n        }\n\n        // Process bids\n        const bs = datum.bs || [];\n        const bids = [];\n        for (const [price, size, timestamp] of bs) {\n            bids.push(new Level2Point(price, size, undefined, undefined, timestamp));\n        }\n\n        // Calculates the newest timestamp value to maintain backwards\n        // compatibility with the update timestamp\n        const timestamp = Math.max(...asks.concat(bids).map(p => parseFloat(p.timestamp)));\n\n        return new Level2Snapshot({\n            exchange: this.name,\n            base: market.base,\n            quote: market.quote,\n            timestampMs: parseInt((timestamp * 1000) as any),\n            asks,\n            bids,\n        });\n    }\n\n    /**\n    Since Kraken doesn't send a trade id, we need to come up with a way\n    to generate one on our own. The REST API include the last trade id\n    which gives us the clue that it is the second timestamp + 9 sub-second\n    digits.\n\n    The WS will provide timestamps with up to 6 decimals of precision.\n    The REST API only has timestamps with 4 decimal of precision.\n\n    To maintain consistency, we're going to use the following formula:\n      <integer part of unix timestamp> +\n      <first 4 digits of fractional part of unix timestamp> +\n      00000\n\n\n    We're using the ROUND_HALF_UP method. From testing, this resulted\n    in the best rounding results. Ids are in picoseconds, the websocket\n    is broadcast in microsecond, and the REST results are truncated to\n    4 decimals.\n\n    This mean it is impossible to determine the rounding algorithm or\n    the proper rounding to go from 6 to 4 decimals as the 6 decimals\n    are being rounded from 9 which causes issues as the half\n    point for 4 digit rounding\n      .222950 rounds up to .2230 if the pico_ms value is > .222295000\n      .222950 rounds down to .2229 if the pico_ms value is < .222295000\n\n    Consumer code will need to account for collisions and id mismatch.\n   */\n    protected _createTradeId(unix: string): string {\n        const roundMode = Decimal.ROUND_HALF_UP;\n        const [integer, frac] = unix.split(\".\");\n        const fracResult = new Decimal(\"0.\" + frac)\n            .toDecimalPlaces(4, roundMode)\n            .toFixed(4)\n            .split(\".\")[1];\n        return integer + fracResult + \"00000\";\n    }\n}\n\n/**\n * Maps the candle period from CCXWS to those required by the subscription mechanism\n * as defined in https://www.kraken.com/en-us/features/websocket-api#message-subscribe\n * @paramp\n */\nfunction getCandlePeriod(p: CandlePeriod) {\n    switch (p) {\n        case CandlePeriod._1m:\n            return 1;\n        case CandlePeriod._5m:\n            return 5;\n        case CandlePeriod._15m:\n            return 15;\n        case CandlePeriod._30m:\n            return 30;\n        case CandlePeriod._1h:\n            return 60;\n        case CandlePeriod._4h:\n            return 240;\n        case CandlePeriod._1d:\n            return 1440;\n        case CandlePeriod._1w:\n            return 10080;\n        case CandlePeriod._2w:\n            return 21600;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}