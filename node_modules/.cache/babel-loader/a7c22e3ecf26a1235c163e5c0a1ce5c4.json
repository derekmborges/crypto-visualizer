{"ast":null,"code":"\"use strict\";\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\n/* eslint-disable @typescript-eslint/no-implied-eval */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.batch = exports.Batch = void 0;\n\nclass Batch {\n  constructor(fn, batchSize) {\n    let collectMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this.fn = fn;\n    this.batchSize = batchSize;\n    this.collectMs = collectMs;\n    this._handle;\n    this._args = [];\n  }\n\n  add() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    this._args.push(args);\n\n    this._unschedule();\n\n    this._schedule();\n  }\n\n  cancel() {\n    this._unschedule();\n\n    this._args = [];\n  }\n\n  _unschedule() {\n    clearTimeout(this._handle);\n  }\n\n  _schedule() {\n    this._handle = setTimeout(this._process.bind(this), this.collectMs);\n\n    if (this._handle.unref) {\n      this._handle.unref();\n    }\n  }\n\n  _process() {\n    if (!this._args.length) return;\n\n    while (this._args.length) {\n      this.fn(this._args.splice(0, this.batchSize));\n    }\n  }\n\n}\n\nexports.Batch = Batch;\n/**\n * Batcher allows repeated calls to a function but will delay execution of the\n * until the next tick or a timeout expires. Upon expiration, the function is\n * called with the arguments of the calls batched by the batch size\n *\n * @example\n * const fn = n => console.log(n);\n * const batchFn = batch(fn, debounceMs);\n * batchFn(1);\n * batchFn(2);\n * batchFn(3);\n * // [[1],[2],[3]]\n */\n\nfunction batch(fn) {\n  let batchSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_SAFE_INTEGER;\n  let collectMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const inst = new Batch(fn, batchSize, collectMs);\n  const add = inst.add.bind(inst);\n  add.cancel = inst.cancel.bind(inst);\n  return add;\n}\n\nexports.batch = batch;","map":{"version":3,"sources":["/Users/Derek/workspace/crypto-visualizer/node_modules/ccxws/src/flowcontrol/Batch.ts"],"names":[],"mappings":";AAAA;;AACA;;AACA;;;;;;;AAIA,MAAa,KAAb,CAAkB;AAId,EAAA,WAAA,CAAqB,EAArB,EAAsC,SAAtC,EAAuF;AAAA,QAArB,SAAqB,uEAAD,CAAC;AAAlE,SAAA,EAAA,GAAA,EAAA;AAAiB,SAAA,SAAA,GAAA,SAAA;AAA4B,SAAA,SAAA,GAAA,SAAA;AAC9D,SAAK,OAAL;AACA,SAAK,KAAL,GAAa,EAAb;AACH;;AAEM,EAAA,GAAG,GAAQ;AAAA,sCAAJ,IAAI;AAAJ,MAAA,IAAI;AAAA;;AACd,SAAK,KAAL,CAAW,IAAX,CAAgB,IAAhB;;AACA,SAAK,WAAL;;AACA,SAAK,SAAL;AACH;;AAEM,EAAA,MAAM,GAAA;AACT,SAAK,WAAL;;AACA,SAAK,KAAL,GAAa,EAAb;AACH;;AAES,EAAA,WAAW,GAAA;AACjB,IAAA,YAAY,CAAC,KAAK,OAAN,CAAZ;AACH;;AAES,EAAA,SAAS,GAAA;AACf,SAAK,OAAL,GAAe,UAAU,CAAC,KAAK,QAAL,CAAc,IAAd,CAAmB,IAAnB,CAAD,EAA2B,KAAK,SAAhC,CAAzB;;AACA,QAAI,KAAK,OAAL,CAAa,KAAjB,EAAwB;AACpB,WAAK,OAAL,CAAa,KAAb;AACH;AACJ;;AAES,EAAA,QAAQ,GAAA;AACd,QAAI,CAAC,KAAK,KAAL,CAAW,MAAhB,EAAwB;;AACxB,WAAO,KAAK,KAAL,CAAW,MAAlB,EAA0B;AACtB,WAAK,EAAL,CAAQ,KAAK,KAAL,CAAW,MAAX,CAAkB,CAAlB,EAAqB,KAAK,SAA1B,CAAR;AACH;AACJ;;AApCa;;AAAlB,OAAA,CAAA,KAAA,GAAA,KAAA;AAuCA;;;;;;;;;;;;AAYG;;AACH,SAAgB,KAAhB,CACI,EADJ,EAGyB;AAAA,MADrB,SACqB,uEADD,MAAM,CAAC,gBACN;AAAA,MAArB,SAAqB,uEAAD,CAAC;AAErB,QAAM,IAAI,GAAG,IAAI,KAAJ,CAAU,EAAV,EAAc,SAAd,EAAyB,SAAzB,CAAb;AACA,QAAM,GAAG,GAAG,IAAI,CAAC,GAAL,CAAS,IAAT,CAAc,IAAd,CAAZ;AACA,EAAA,GAAG,CAAC,MAAJ,GAAa,IAAI,CAAC,MAAL,CAAY,IAAZ,CAAiB,IAAjB,CAAb;AACA,SAAO,GAAP;AACH;;AATD,OAAA,CAAA,KAAA,GAAA,KAAA","sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-implied-eval */\n\nimport { CancelableFn, Fn } from \"./Fn\";\n\nexport class Batch {\n    protected _handle: NodeJS.Timeout;\n    protected _args: any[];\n\n    constructor(readonly fn: Fn, readonly batchSize: number, readonly collectMs: number = 0) {\n        this._handle;\n        this._args = [];\n    }\n\n    public add(...args) {\n        this._args.push(args);\n        this._unschedule();\n        this._schedule();\n    }\n\n    public cancel() {\n        this._unschedule();\n        this._args = [];\n    }\n\n    protected _unschedule() {\n        clearTimeout(this._handle);\n    }\n\n    protected _schedule() {\n        this._handle = setTimeout(this._process.bind(this), this.collectMs);\n        if (this._handle.unref) {\n            this._handle.unref();\n        }\n    }\n\n    protected _process() {\n        if (!this._args.length) return;\n        while (this._args.length) {\n            this.fn(this._args.splice(0, this.batchSize));\n        }\n    }\n}\n\n/**\n * Batcher allows repeated calls to a function but will delay execution of the\n * until the next tick or a timeout expires. Upon expiration, the function is\n * called with the arguments of the calls batched by the batch size\n *\n * @example\n * const fn = n => console.log(n);\n * const batchFn = batch(fn, debounceMs);\n * batchFn(1);\n * batchFn(2);\n * batchFn(3);\n * // [[1],[2],[3]]\n */\nexport function batch(\n    fn: Fn,\n    batchSize: number = Number.MAX_SAFE_INTEGER,\n    collectMs: number = 0,\n): CancelableFn {\n    const inst = new Batch(fn, batchSize, collectMs);\n    const add = inst.add.bind(inst);\n    add.cancel = inst.cancel.bind(inst);\n    return add as CancelableFn;\n}\n"]},"metadata":{},"sourceType":"script"}