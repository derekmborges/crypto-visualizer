{"ast":null,"code":"\"use strict\";\n/* eslint-disable @typescript-eslint/no-implied-eval */\n\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Watcher = void 0;\n/**\n * Watcher subscribes to a client's messages and\n * will trigger a restart of the client if no\n * information has been transmitted in the checking interval\n */\n\nclass Watcher {\n  constructor(client) {\n    let intervalMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 90000;\n    this.client = client;\n    this.intervalMs = intervalMs;\n    this._intervalHandle = undefined;\n    this._lastMessage = undefined;\n    client.on(\"ticker\", this.markAlive.bind(this));\n    client.on(\"candle\", this.markAlive.bind(this));\n    client.on(\"trade\", this.markAlive.bind(this));\n    client.on(\"l2snapshot\", this.markAlive.bind(this));\n    client.on(\"l2update\", this.markAlive.bind(this));\n    client.on(\"l3snapshot\", this.markAlive.bind(this));\n    client.on(\"l3update\", this.markAlive.bind(this));\n  }\n  /**\n   * Starts an interval to check if a reconnction is required\n   */\n\n\n  start() {\n    this.stop(); // always clear the prior interval\n\n    this._intervalHandle = setInterval(this._onCheck.bind(this), this.intervalMs);\n  }\n  /**\n   * Stops an interval to check if a reconnection is required\n   */\n\n\n  stop() {\n    clearInterval(this._intervalHandle);\n    this._intervalHandle = undefined;\n  }\n  /**\n   * Marks that a message was received\n   */\n\n\n  markAlive() {\n    this._lastMessage = Date.now();\n  }\n  /**\n   * Checks if a reconnecton is required by comparing the current\n   * date to the last receieved message date\n   */\n\n\n  _onCheck() {\n    if (!this._lastMessage || this._lastMessage < Date.now() - this.intervalMs) {\n      this._reconnect();\n    }\n  }\n  /**\n   * Logic to perform a reconnection event of the client\n   */\n\n\n  _reconnect() {\n    this.client.reconnect();\n    this.stop();\n  }\n\n}\n\nexports.Watcher = Watcher;","map":{"version":3,"sources":["/Users/Derek/workspace/crypto-visualizer/node_modules/ccxws/src/Watcher.ts"],"names":[],"mappings":";AAAA;;AACA;;AACA;;AACA;;;;;;AAEA;;;;AAIG;;AACH,MAAa,OAAb,CAAoB;AAIhB,EAAA,WAAA,CAAqB,MAArB,EAA6D;AAAA,QAAlB,UAAkB,uEAAL,KAAK;AAAxC,SAAA,MAAA,GAAA,MAAA;AAAsB,SAAA,UAAA,GAAA,UAAA;AACvC,SAAK,eAAL,GAAuB,SAAvB;AACA,SAAK,YAAL,GAAoB,SAApB;AAEA,IAAA,MAAM,CAAC,EAAP,CAAU,QAAV,EAAoB,KAAK,SAAL,CAAe,IAAf,CAAoB,IAApB,CAApB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,QAAV,EAAoB,KAAK,SAAL,CAAe,IAAf,CAAoB,IAApB,CAApB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,OAAV,EAAmB,KAAK,SAAL,CAAe,IAAf,CAAoB,IAApB,CAAnB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,YAAV,EAAwB,KAAK,SAAL,CAAe,IAAf,CAAoB,IAApB,CAAxB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,UAAV,EAAsB,KAAK,SAAL,CAAe,IAAf,CAAoB,IAApB,CAAtB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,YAAV,EAAwB,KAAK,SAAL,CAAe,IAAf,CAAoB,IAApB,CAAxB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,UAAV,EAAsB,KAAK,SAAL,CAAe,IAAf,CAAoB,IAApB,CAAtB;AACH;AAED;;AAEG;;;AACI,EAAA,KAAK,GAAA;AACR,SAAK,IAAL,GADQ,CACK;;AACb,SAAK,eAAL,GAAuB,WAAW,CAAC,KAAK,QAAL,CAAc,IAAd,CAAmB,IAAnB,CAAD,EAA2B,KAAK,UAAhC,CAAlC;AACH;AAED;;AAEG;;;AACI,EAAA,IAAI,GAAA;AACP,IAAA,aAAa,CAAC,KAAK,eAAN,CAAb;AACA,SAAK,eAAL,GAAuB,SAAvB;AACH;AAED;;AAEG;;;AACI,EAAA,SAAS,GAAA;AACZ,SAAK,YAAL,GAAoB,IAAI,CAAC,GAAL,EAApB;AACH;AAED;;;AAGG;;;AACK,EAAA,QAAQ,GAAA;AACZ,QAAI,CAAC,KAAK,YAAN,IAAsB,KAAK,YAAL,GAAoB,IAAI,CAAC,GAAL,KAAa,KAAK,UAAhE,EAA4E;AACxE,WAAK,UAAL;AACH;AACJ;AAED;;AAEG;;;AACK,EAAA,UAAU,GAAA;AACd,SAAK,MAAL,CAAY,SAAZ;AACA,SAAK,IAAL;AACH;;AAxDe;;AAApB,OAAA,CAAA,OAAA,GAAA,OAAA","sourcesContent":["/* eslint-disable @typescript-eslint/no-implied-eval */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n/**\n * Watcher subscribes to a client's messages and\n * will trigger a restart of the client if no\n * information has been transmitted in the checking interval\n */\nexport class Watcher {\n    private _intervalHandle: NodeJS.Timeout;\n    private _lastMessage: number;\n\n    constructor(readonly client: any, readonly intervalMs = 90000) {\n        this._intervalHandle = undefined;\n        this._lastMessage = undefined;\n\n        client.on(\"ticker\", this.markAlive.bind(this));\n        client.on(\"candle\", this.markAlive.bind(this));\n        client.on(\"trade\", this.markAlive.bind(this));\n        client.on(\"l2snapshot\", this.markAlive.bind(this));\n        client.on(\"l2update\", this.markAlive.bind(this));\n        client.on(\"l3snapshot\", this.markAlive.bind(this));\n        client.on(\"l3update\", this.markAlive.bind(this));\n    }\n\n    /**\n     * Starts an interval to check if a reconnction is required\n     */\n    public start() {\n        this.stop(); // always clear the prior interval\n        this._intervalHandle = setInterval(this._onCheck.bind(this), this.intervalMs);\n    }\n\n    /**\n     * Stops an interval to check if a reconnection is required\n     */\n    public stop() {\n        clearInterval(this._intervalHandle);\n        this._intervalHandle = undefined;\n    }\n\n    /**\n     * Marks that a message was received\n     */\n    public markAlive() {\n        this._lastMessage = Date.now();\n    }\n\n    /**\n     * Checks if a reconnecton is required by comparing the current\n     * date to the last receieved message date\n     */\n    private _onCheck() {\n        if (!this._lastMessage || this._lastMessage < Date.now() - this.intervalMs) {\n            this._reconnect();\n        }\n    }\n\n    /**\n     * Logic to perform a reconnection event of the client\n     */\n    private _reconnect() {\n        this.client.reconnect();\n        this.stop();\n    }\n}\n"]},"metadata":{},"sourceType":"script"}